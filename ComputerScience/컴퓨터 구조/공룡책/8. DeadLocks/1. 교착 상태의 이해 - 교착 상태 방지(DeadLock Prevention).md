1. 시스템 모델(System Model)
	- 교착 상태(DeadLock)이란
		- 어떤 다른 프로세스에 의해 발생된 이벤트에 의해서 모든 프로세스가 대기하는 현상
		- 요청한 자원을 다른 대기중인 쓰레드가 점유하고 있기 때문에 자원을 요청한 대기중인 쓰레드(또는 프로세스)는 다시는 쓰레드 상태를 변경할 수 없다.
		여러 개의 경쟁하는 쓰레드 사이에서 분배가 될 유한한 수의 자원으로 구성된 시스템의 경우, 자원의 종류는 몇 가지 동일한 인스턴스로 구성된다. 예를 들어 CPU 사이클, 파일, 입출력 기기(프린터, 드라이브 등)이 있다. CPU 사이클이 4개의 코어로 구성되었다면 한 번에 4개의 쓰레드를 수행할 수 있고 그 이후의 쓰레드는 대기해야 한다.
		만약 어떤 한 쓰레드가 동일한 자원 유형의 인스턴스를 요청한다면 어떤 인스턴스의 할당이 요청을 만족하면 된다.
		어떤 한 쓰레드는 자원이 필요할 때 "자원 요청->자원 사용->자원 해제"와 같은 순서로 사용할 수 잇다. 여기서 자원의 사용은 임계 영역(Critical Section)을 의미하며 임계 영역에는 여러 개의 자원을 사용하는 것을 의미한다.
2. 멀티 쓰레딩 애플리케이션의 교착 상태
	- 교착 상태(DeadLocks)는 어떻게 발생하는지
		- 교착 상태의 대표적인 사례는 어떤 한 프로세스가 A라는 자원을 점유한 상태에서 B라는 자원을 점유하고자 할 때 B 자원을 가지고 있는 프로세스가 A 자원을 점유하고자 할 때 발생하는 것이 있다.
		- 
		  ![[Pasted image 20240324223739.png]]
		  - 쓰레드 A는 do_work_one 함수를 수행하고 쓰레드 B는 do_work_two 함수를 수행한다고 가정
		  - 만약 쓰레드 A가 first_mutex lock을 가지고 쓰레드 B가 second_mutex lock 을 가진다고 가정
		  - 그리고 쓰레드 A는 second_mutex의 lock을 가지고자 second_mutex lock이 해제될 때 까지 대기
		  - 그리고 쓰레드 B는 first_mutex의 lock을 가지고자 first_mutex lock이 해제될 때 까지 대기
		  - 쓰레드 A, B는 서로 가지고 있는 lock이 해제될 때 까지 대기하며 교착 상태 발생
3. 교착 상태의 특징
	- 교착 상태 발생 조건 4가지
		- 상호 배제(Mutual Exclusion)
			- 최소 한 개의 자원이 임계 영역에서 점유
		- 점유와 대기(Hold and Wait)
			- 어떤 한 쓰레드가 최소 한 개의 자원을 점유하고 다른 쓰레드가 가지고 있는 추가적인 자원을 얻고자 대기하게 되면 교착 상태 발생 조건을 만족한다.
		- 선점 불가(No Preemption)
			- 자원들이 선점이 불가능 할 때 교착 상태 발생 조건을 만족한다.
			- 자원들의 종류에는 CPU 사이클, 파일, 입출력 기기 등이 존재한다.
		- 원형 대기(Circular Wait)
			- 대기중인 쓰레드들의 집합이 종속적인 대기 그래프가 원형이 존재할 때 발생한다.
			- 예를 들어 A 쓰레드가 B 쓰레드의 자원을 원하고 B 쓰레드가 C 쓰레드의 자원을 원한 상태에서 C 쓰레드가 A 쓰레드의 자원을 원할 때, 이와 같은 형태를 원형 대기라고 한다.
			- 원형 대기는 최소 2개 이상의 쓰레드에서 발생할 수 있다.
	- 자원 할당 그래프(Resource-Allcation Graph)
		![[Pasted image 20240324224843.png]]
		- 자원 할당 그래프는 교착 상태를 더 쉽게 이해하기 위한 방향성 그래프이다.
		- 자원 할당 그래프는 정점의 집합 V와 간선의 집합 E로 구성되어 있다.
		- 정점의 두 가지 종류
			- T = { T1, T2, . . . , Tn } : 시스템에서 활성화된 쓰레드의 집합
			- R = { R1, R2, . . . , Rn } : 시스템에서 모든 자원 유형의 집합
		- 방향성 간선 : Ti -> Rj(요청 간선)
			- 쓰레드 i가 자원 Rj를 요청한다.
		- 방향성 간선 : Rj -> Ti(할당 간선)
			- 자원 Rj가 쓰레드 i에 할당되는 것을 의미한다.
		- 쓰레드 1에는 first_mutex lock이 할당되어 있고 second_mutex 자원을 요청하는 상태이다.
		- 쓰레드 2에는 second_mutex lock이 할당되어 있고 first_mutex 자원을 요청하는 상태이다.
	- 자원-할당 그래프를 집합으로 표현
	   ![[Pasted image 20240324225040.png]]
		- 다음 집합을 통해 쓰레드 T1은 R1 자원을 요청하고  T2는 R3 자원을 요청한 상태이다.
		- 자원 할당 상황은 T1에는 R2 자원이 할당되고, T2에는 R1, R2가 할당됨, T3에는 R3가 할당됨을 알 수 있다.
		-  위 그래프를 통해 쓰레드 T3는 작업을 언젠가 마치고 T2->T1 순으로 자원을 할당받게 되어서 수행을 마칠 것이다. 즉, 교착 상태가 발생하지 않을 것이다.
	- 교착 상태가 발생하는 자원-할당 그래프
		![[Pasted image 20240324225301.png]]
		- 중요한 점은 R2가 T1과 T2에 할당되어 있기 때문에 원형 대기가 발생하여 교착 상태가 발생한다는 점이다.
	- 교착 상태가 발생하지 않는 자원-할당 그래프
		![[Pasted image 20240324225335.png]]
		- T1->R1->T3->T2로 원형이 생성되었지만 R1과 R2 자원 유형은 인스턴스가 각각 2개 이다.
		- T2와 T4가 작업을 마치고 R1, R2 자원을 반환하면서 T3, T1도 작업을 마칠 수 있기 때문에 교착 상태가 발생하지 않는다.
	- 자원 할당 그래프로 보는 교착 상태
		- 자원 할당 그래프가 원형(Cycle)을 가지고 있지 않다면 교착 상태가 확정적으로 발생하지 않는다.
		- 자원 할당 그래프가 원형(Cycle)을 가지고 있더라도 교착 상태가 무조건적으로 발생하지는 않는다.
4. 교착 상태를 다루기 위한 방법
	- 교착 상태를 벗어나기 위한 3가지 방법
		- 문제를 완전히 무시하는 방법
			- 마치 시스템에서 교착 상태가 무조건 발생하지 않는 척 한다.
		- 교착 상태를 방지(Prevent)하거나 회피(Avoid)하는 방식을 사용
			- 교착 상태 방지 : 교착 상태로 진입하는 것을 절대로 방지하는 방식. 하지만 교착 상태 방지는 거의 불가능한 방법이다.
			- 교착 상태 회피 : Banker's Algorithm
		- 교착 상태가 발생하는 것을 허용하는 방법
			- 탐색(Detect)하고 회복(Recover)하는 절차를 수행
			- 교착 상태 탐색 : 교착 상태가 발생하는지 탐색하는 연산
			- 교착 상태 회복 : 교착 상태가 발생하기 이전으로 되돌아가는 연산
5. 교착 상태 방지(DeadLock Prevention)
	교착 상태 방지의 아이디어는 교착 상태가 발생하는 조건 4가지(상호 배제, 점유와 대기, 선점 불가, 원형 대기) 중 하나가 발생하는 것을 막는 방법
	- 상호 배제(Mutual Exclusion)을 방지하는 방법
		- 상호 배제가 발생하는 조건은 최소 하나의 자원이 공유 불가능해야 한다는 점이다.
		- 반대로 방지하기 위해서는 모든 자원이 공유되면 교착 상태를 막을 수 있다는 주장이다. 하지만 일반적으로 이 방법은 대부분의 애플리케이션에 적용할 수 없는 방법이다.
			- 몇몇 자원들은 본질적으로 공유가 되면 안되기 때문
			- 예를 들어 뮤텍스 락 같은 자원의 경우 여러 쓰레드에 의해서 공유되면 안되는 자원이다.
		- 즉, 상호 배제를 방지하는 방법을 불가능하다.
	- 점유와 대기(Hold and Wait)을 방지하는 방법
		- 점유와 대기를 방지하는 방법은 어떤 한 쓰레드가 자원을 요청할 때 이미 점유하고 있는 자원을 해제한 다음 요청하는 방식.
		- 예를 들어 어떤 한 쓰레드가 A라는 자원을 요청할 때 B라는 다른 자원을 이미 점유하고 있다면 점유하고 있는 A 자원을 해제하고 요청한 B 자원을 얻을 때 까지 대기한다. 그리고 요청한 B 자원을 얻은 다음 이전에 해제한 A 자원을 요청하여 자원을 얻는다.
		- 하지만 점유와 대기를 방지하는 방법은 대부분의 응용 프로그램에서 비 실용적이다.
	- 선점 불가(No Preemption)를 방지하는 방법
		- 선점 불가를 방지하는 방법은 자원을 점유하고 있는 쓰레드에 대해서 선점하여 자원을 내려 놓게 하는 방법이다.
		- 예를 들어 어떤 한 쓰레드가 A라는 자원을 가지고 있는 상태에서 B라는 자원을 요청한다. 그런데 B 자원은 다른 쓰레드가 점유하고 있는 상황이라면 다른 쓰레드가 갖고 있는 B자원을 해제하여 선점한다.
		- 점유와 대기를 방지하는 방법은 마찬가지로 대부분의 응용 프로그램에서는 일반적으로 적용할 수 없다.
	- 원형 대기(Circular Wait)를 방지하는 방법 : 제일 실용적인 방법
		- 모든 자원 유형들에 순서를 지정
		- 각각의 쓰레드가 자원을 오름차순으로 요청하는 것을 요구
		- 내가 점유하고 있는 자원보다 높은 자원 유형들만 요청. 즉, 내가 점유하고 있는 자원보다 낮은 자원들은 요청하는 것을 막는다.
		- 하지만 이와 같은 방법은 기아(Starvation) 발생 가능성이 높아지는 단점이 있다.
		- 그러나 이러한 방법도 교착 상태 방지를 보장할 수는 없다.
			![[Pasted image 20240325040846.png]]
		- 위 Transaction 연산은 원자적인 연산이기 때문에 다른 쓰레드에 의해서 선점될 수 없다.
		- 하지만 문제가 되는 부분은 첫 번째 Transaction 연산 중에 두 번째 Transaction 연산이 발생하여 교착 상태 문제가 발생할 수 었다.
- 정리
	- 교착 상태는 상호 배제, 점유와 대기, 선점 불가, 원형 대기 4가지 조건이 만족하면 발생한다.
	- 교착 상태를 해결하는 방법에는 무시, 방지, 회피, 탐색 후 회피가 있다.
	- 교착 상태 방지 방법 중 상호 배제, 점유와 대기, 선점 불가를 방지하는 방법은 실용적이지 못하고 원형 대기를 방지하는 방법은 가장 실용적이지만 교착 상태를 방지하는 것을 보장하지는 못한다.
