- 전처리 지시자
	- C++ 소스코드를 프로그램으로 만드는 빌드작업은 세 단계를 거침
		- 전처리  : 소스코드에 담긴 메타 정보를 처리
		- 컴파일 : 소스코드를 머신이읽을 수 있는 객체 파일로 변환
		- 링크 : 변환한 여러 객체 파일을 애플리케이션으로 엮음
- 자주 사용하는 전처리 지시자
 
| 전처리 지시자 | 기능 | 사용 예 |
|---|---|---|
| #include [파일] | 지정한 '파일'의 내용을 지시자 위치에 넣음 | 다른 곳에서 정의된 함수를 사용할 목적으로 해당 함수의 선언문이 담긴 헤더 파일을 가져옴 |
| #define [키][값]| 코드에서 '키'에 해당하는 부분을 모두 '값'으로 지정한 내용으로 바꿈 | C에서는 주로 상숫값이나 매크로를 정의하는 데 사용. C++은 상수 및 매크로 정의에 대해 좀 더 개선된 메커니즘을 제공. 매크로는 자칫 위험할 수 있어서 사용시 주의. |
| #ifdef [키], #endif | ifdef(if defined)는 지정한 '키'가 #define 문으로 정의되어 있으면 ifdef로 묶인 코드 블록을 포함시키고, 정의되어 있지 않으면 포함시키지 않는다. | 주로 인클루드 문장이 중복해서 추가되는 것을 막는 용도로 사용. #ifndef로 헤더 파일을 불러오면 먼저 '키'값이 정의되어 있는지 확인한 뒤, 없을시 #define 지시자로 그 '키'를 정의. 그리고 #endif 지시자로 헤더 파일 추가 구문을 닫는다. 이럴시 같은 파일이 여러 번 추가되는 일을 방지할 수 있음 |
| #ifndef [키], #endif | ifndef(if not defined)는 지정한 '키'가 #define 문으로 정의되어 있지 않으면 ifndef로 묶인 코드 블록을 포함시키고, 정의되어 있으면 포함시키지 않는다. | 위와 동일 |
| #pragma [xyz] | xyz에 대한 구체적 동작은 컴파일러마다 다름. 대부분 컴파일러가 #pragma를 지원하며, 주로 전처리 과정에서 이 지시자에 도달할 때 경고나 에러 메시지를 화면에 표시하는 용도로 사용 | |

- 중복 인클루드를 막는 용도로 전처리 지시자를 사용하는 예시. 
```C++
#ifndef MYHEADER_H
#define MYHEADER_H
// 헤더 파일 참조
#endif

// 현재는 #pragma once로 대체
```

- main 함수
	프로그램은 항상 main 함수에서 시작하며, main함수는 int 타입의 값을 리턴. 이 값으로 프로그램의 실행 상태를 표시할 수 있음. main 함수는 매개변수를 받지 않거나 두 개를 받도록 작성할 수 있음
	==int main(int argc, char* argv[])==
	argc는 프로그램에 전달할 인수의 개수를 지정하고, argv는 전달할 인수의 값을 담음. argv[0]에는 프로그램의 이름이 담기는데, 공백 스트링으로 지정될 수도 있어서 프로그램 이름을 참조하려면 이 값보다는 플랫폼에서 제공하는 기능을 사용하는 것이 좋음. 주의할 점은 실제 매개변수는 인덱스 1부터 시작한다는 점.
	
- I/O Stram
	endl은 스트림에 줄바꿈 문자를 추가한 뒤 현재 버퍼에 있는 내용을 출력 장치로 내보낸다. endl은 성능에 영향을 미치기 때문에 특히 루프와 같은 문장에서 남용하면 좋지 않지만, <font color="red">\n은 스트림에 줄바꿈 문자를 추가하지만 버퍼를 자동으로 비우지 않는다.</font>
	C++에서는 format 함수나 스트림 라이브러리를 사용하는 것이 바람직하다. <font color="yellow">C에서 사용하는 printf()나 scanf() 함수는 타입 안정성을 보장하지 않기 때문이다.</font>
	
- 네임스페이스
	코드에서 이름이 서로 충돌하는 문제를 해결하기 위해 나온 개념으로, 네임스페이스 안에 함수 혹은 변수가 정의되면 네임스페이스의 스코프 지정 연산자(::)를 이용하여 구분할 수 있다.
	네임스페이스 블록 안에서 접근할 때는 네임스페이스 접두어를 붙이지 않아도 되며. 이렇게 네임스페이스를 생략하면 코드의 가독성을 좀 더 높일 수 있다. 또한 using 지시자로 네임스페이스 접두어를 생략할 수 있는데, 컴파일러는 using 지시자를 보면 그 뒤에 나오는 문장부터는 using에 지정된 네임스페이스에 속한다고 처리하게 된다.
	하지만 using을 사용하여 네임스페이스를 전부 지우게 되면 사실상 네임스페이스가 없는것과 동일하게 되는서 남용하면 안된다. 다른 해결 방법으로는 해당 네임스페이스 안에 있는 <font color="yellow">함수를 따로 using 지시자를 사용하여 선언하는 것이 가장 효과적이다.</font>
- 중첩 네임스페이스
	다른 네임스페이스 안에 있는 네임스페이스를 의미한다.
	==MyLibraris::Networking::FTP==
- 네임스페이스 앨리어스
	네임스페이스 앨리어스를 사용하면 네임스페이스의 이름을 다르게 만들거나 또는 더 짧게 만들 수 있다.
	==namespace MyFTP = MyLibraris::Networking::FTP;==

- 리터럴
	코드에 표시한 숫자나 스트링과 같은 값을 의미한다. C++은 다양한 표준 리터럴을 제공한다.
	- 십진수 리터럴 : 123
	- 8진수 리터럴 : 0173
	- 16진수 리터럴 : 0x7B
	- 이진수 리터럴 : 0b1111011
	정수형이 아닌 다른 리터럴로는
	- 부동 소수점(float) : 3.14f
	- 배정도 부동 소수점(double) : 3.14
	- 16진수 부동 소수점 : 0x3.ABCp-10, 0Xb.cp121
	- 단일 문자 : 'a'
	- 0으로 끝나는 문자 배열 : "character array"
	숫자 리터럴에서는 자릿수 구분자를 사용할 수 있다. 자릿수 구분자는 작은 따옴표로 표현한다.
	- 23'456'789
	- 0.123'456f

- 변수
	변수를 선언할 때 반드시 값을 대입(초기화)할 필요는 없지만, 초기화하지 않은 변수는 선언할 시점의 메모리가 가지고있는 값을 기반으로 무작위 값이 대입될 수 있으며 해당 현상으로 버그가 발생할 가능성이 있기 때문에 초기화 해주는 것이 좋다. 초기화는 선언시에 대입연산자, 소괄호, 중괄호를 사용하여 처리할 수 있다.
	- 균일 초기화
		- 균일 초기화의 장점중 하나는 <font color="red">좁히기 변환(narrowing conversion)을 방지해준다.</font>
		  ==double x, y, z;==
		  ==int sum{ x + y + z };==
		  위와 같은 코드에서 균일 초기화를 사용하게 되면 축소변환이 불가능하게 되어 컴파일러가 에러를 발생하게 된다.
		- 또 한가지는 구문해석(most vexing parse)에서 자유롭다는 점이다. 생성자를 호출하려 할 때 컴파일러가 함수명인지 변수명인지 구분하기 어려워 발생하는 오류이다.
		  ==Widget w1(); // w1이라는 함수 선언==
		  ==Widget w2{}; // 인수 없는 생성자 호출==
		  균일 초기화를 사용하게 되면 문제없이 생성자를 호출하게 된다.<font color="yellow">사실 내 생각으로는 가독성이 떨어져보이기 때문에 사용하지 2번의 예시처럼 사용하지 않는 편이 더 좋아 보인다.</font>
	- 영 초기화
		- 변수는 유니폰 초기자(Uniform Initializer, 균일 초기자) {0}을 이용하여 0으로 초기화할 수 있다. 이때 0은 생략해도 된다. 빈 중괄호 {}로 표기한 유니폼 초기자를 영 초기자(Zero Initializer)라 한다. 영 초기자는 기본 정수 타입(char, int 등)을 0으로, 기본 부동 소수점 타입을 0.0으로, 포인터 타입을 nullptr로, 객체를 디폴트 생성자로 초기화한다.
	- 캐스트
		변수의 타입은 런타임때 바꿀 수 있다. 이를 캐스트(Cast)라 한다. C++에서 변수의 타입을 명시적으로 변환하는 방법은 세 가지다.
		- `(int)variable` : C언어에서 사용하던 것으로 C++에서는 피해야 할 방식이다.
		- `int(variable)` : 거의 사용하지 않는다.
		- `static_cast<int>(variable)` : 가장 명확해서 권장하는 방식.
		변수를 자동 캐스팅할 때 데이터가 손실될 수 있다는 점에 주희해야 한다. 
	- 부동소수점수
		소수점 자리가 다른 부동소수점수끼리 연산할 때 에러가 발생할 가능성이 있다. 또한 거의 동일한 부동소수점수끼리 뺄셈을 할 때 정밀도 손실이 발생할 수 있다.
		부동소수점수 중에는 특별한 값이 잇다.
		- +/-무한 : 예를 들어 0을 0으로 나눈 결과와 같이 양의 무한과 음의 무한을 나타낸다.
		- NaN : Npt a Number(숫자가 아님)의 줄임말이다.
		주어진 부동소수점수가 NaN인지 확인하려면 std::isnan( )을 사용한다. 무한인지 검사하려면 std::isinf( )를 사용한다. 둘 다 cmath 라이브러리에 정의되어 있다.
		이처럼 특별한 부동소수점수를 구하려면 numeric_limits를 활용한다.

- 연산자
	C++ 연산자는 표현식 두 개를 계산하는 이항(binary) 연산자, 표현식 하나만 계산하는 단항(unary) 연산자, 표현식 세 개를 계산하는 삼항(temary) 연산자로 분류할 수 있다. C++에서 삼항 연산자는 딱 하나뿐이다.

- 열거 타입
	열가 타입의 값이 내부적으로 정수로 표현되다고 해서 자동으로 정수로 변환되지 않는다. 기본적으로 열거 타입의 값은 정수 타입(int)로 저장되지만 내부 표현 타입을 다른 타입으로 바꿀 수 있다.
	
	`enum class EnumType : unsigne long`
	
	enum으로 정의한 열가 타입 값의 스코프(scope, 유효 범위)는 자동으로 확장된다. 즉, 상위 스코프에서 열거 타입 멤버의 이름을 그대로 사용할 수가 있어서 충돌이 발생한다는 것이다. 또한, 열거타입과 변수명과도 충돌이 발생한다. 이처럼 열거 타입은 강타입이 아니기 때문에 타입에 안전하지 않다.	
	enum class로 정의한 열가 타입 값의 스코프는 자동으로 확장되지 않는다. 즉, 상위 스코프에 동일한 이름이 있어도 충돌되지 않는다는 것이다.

- 구조체
	구조체를 사용하면 기존에 정의된 타입을 한 개 이상 묶어서 새로운 타입으로 정의할 수 있다. 
	구조체 타입으로 선언한 변수는 해당 구조체에 있는 모든 필드(field)를 가진다. 구조체를 구성하는 필드는 도트( . ) 연산자로 접근한다.

- 조건문
	- if문 초기자
		if문 안에 초기자를 넣을 수 있다.
		`if (int a = 10; a > 0) { . . . }`
	- switch문
		switch문은 조건 값이 해당하는 case문 안의 동작을 실행한다. 하지만 break문이 없다면 다음에 나오는 case문도 계속해서 실행하는데 이렇게 실행되는 것을 폴스루(fallthrough)라고 한다.
	- switch문 초기자
		if문처럼 switch문도 초기자를 지정할 수 있다.
		`switch (int a = 10; a) { . . . }`

- 조건 연산자
	조건 연산자(conditioanl operator, ? : )는 C++에서 인수 세 개를 받는 유일한 삼항 연산자로 ?와 : 로 표현한다. 이 연산자는 '(조건)을 만족하면 (동작 1)을 수행하고, 아닐 경우 (동작 2)를 수행한다.'를  '조건 ? 동작1 : 동작2' 형식으로 간략히 표현한다.

- 논리 연산자
	C++은 논리 표현식을 평가할 때 단락 논리(short-circuit logic, 축약 논리)를 사용한다. 즉, 표현식을 평가하는 도중에 최종 결과가 나오면 나머지 부분은 평가하지 않는다.
	이처럼 단락 기능은 프로그램 성능을 높이는 데 도움이 된다. 단락되는 논리식을 작성할 때는 가볍게 검사할 수 잇는 부분을 앞에 적고, 시간이 좀 걸리는 부분은 뒤에 둔다. 또한 포인터값이 올바르지 않으면 그 포인터를 사용하는 표현식이 실행되지 않게 할 때도 단락을 활용하면 좋다.

- 3방향 비교 연산자
	3방향 비교 연산자(tree-way comparison operator)는 두 값의 순서를 결정하는 데 사용된다. 이 연산자는 우주선 연산자(spaceship operator)라고도 부르는데, 연산자 기호인 <=>가 우주선처럼 생겼기 때문이다. 이 연산자는 주어진 표현식의 평가 결과가 비교 대상이 되는 값과 같은지 아니면 그보다 크거나 작은지 알려준다. 이 연산자의 반환값은 compare 라이브러리에 정의되어 있는 std 네임스페이스에 속하는 열거 타입으로 리턴한다. 피연산자가 정수 타입이면 강한 순서(strong ordering)라고 부른다.
	- strong_ordering::less : 첫 번째 피연산자가 두 번째 피연산자보다 작다.
	- strong_ordering::greater : 첫 번째 피연산자가 두 번째 피연산자보다 크다.
	- strong_ordering::equal : 두 피연산자가 같다.
	피연산자가 부동소수점 타입이라면 결과는 부분 순서(partial ordering)다.
	- partial_ordering::less : 첫 번째 피연산자가 두 번째 피연산자보다 작다.
	- partial_ordering::greater : 첫 번재 피연산자가 두 번째 피연산자보다 크다.
	- partial_ordering::equivalent : 두 피연사자가 같다.
	- partial_ordering::unordered : 두 피연산자 중 하나는 숫자가 아니다.
	또한 약한 순서(weak ordering)도 있다. 자신이 직접 정의한 타입에 대해 3방향 비교 연산을 구현할 때 이 타입을 활용할 수 있다.
	- weak_ordering::less : 첫 번째 피연산자가 두 번째 피연산자보다 작다.
	- weak_ordering::greater : 첫 번재 피연산자가 두 번째 피연산자보다 크다.
	- weak_ordering::equivalent : 두 피연산자가 같다.
	기본 타입에 대해서는 3방향 비교 연산자를 사용해도 기존 비교연산자를 사용하는 것보다 좋은 점은 없다. 하지만 비교 작업이 복잡한 객체에서는 상당히 유용하다. 이런 객체의 순서를 비교할 때 다소 무서운 기존 비교 연산자를 두 번 호출할 필요 없이 3방향 비교 연산자 하나만으로 결정할 수 있기 때문이다.
	compair 라이브러리에서는 순서의 결과를 해석해주는 이름 있는 비교 함수(named comparison function)인 std::is_eq(), is_neq(), is_lt(), islteq(), is_gt(), is_gteq()를 제공한다. 각각은 같다, 다르다, 작다, 작거나 같다, 크다, 크거나 같다로 비교한 결과를 true나 false로 리턴한다.

- 함수
	- 함수 리턴 타입 추론
		반환형으 auto 키워드로 적으면 컴파일러가 함수의 리턴 타임을 자동으로 지정해준다. 그러면 컴파일러는 return 문에 나온 표현식의 타입에 따라 리턴 타입을 추론한다. 함수 안에 return 문이 여러 개가 있다면 모두 타입이 같아야 한다. 리턴 값이 재귀 호출(recursive call)일 수도 있는데, 이때는 재귀 호출이 아닌 non-recursive return 문도 반드시 함께 있어야 한다.
	- 현재 함수 이름
		모든 함수는 내부적으로 __func__라는 로컬 변수가 정의되어 있다. 이 변수의 값은 현재 함수의 이름이며, 주로 로그를 남기는데 활용한다.
	- 함수 오버로딩
		함수를 오버로딩(overloading)한다는 말은 이름은 같지만 매개변수 구성은 다른 함수를 여러 개 제공한다는 뜻이다. 리턴 타입만 달라서는 안되며, 매개변수의 타입이나 개수도 달라야 한다.

- 어트리뷰트
	어트리뷰트(attribute)는 소스 코드에 벤더에서 제공하는 정보나 옵션을 추가하는 메커니즘이다. C++ 표준에 어트리뷰트가 추가되기 전에는 벤더마다 이런 정보를 지정하는 방법이 달랐다. 예를 들어 `__attribute__`, `__declspec` 등을 사용했지만, C++11부터는 `[[어트리뷰트]]`와 같이 대괄호를 이용한 형식을 사용하도록 표준화되기 시작했다.
	switch case문에서 의도적으로 폴스루 방식으로 작성했을 때 컴파일러에 경고 메시지를 출력하지 말라고 알리기 위해 `[[fallthrough]]` 어트리뷰트를 사용할 수 있다.
	- `[[nodiscard]]`
		어떤 값을 리턴하는 함수에 대해 지정할 수 있다. 그러면 컴파일러는 이 함수가 호출될 때 리턴값에 아무런 작업을 하지 않으면 경고 메시지를 출력한다.
		이 기능은 에러 코드를 리턴하는 함수 등에 활용할 수 있다. 그런 함수에 `[[nodiscard]]`어트리뷰트를 붙이면 에러 코드를 무시하지 않는다.
		일반적으로 `[[nodiscard]]` 어트리뷰트는 클래스, 함수, 열거형에 적용할 수 있다.
		C++20부터 `[[nodiscard]]` 어티리뷰트에 이유를 설명하는 스트링을 추가할 수 있다.
		`[[nodiscard("Test String")]] int function() { . . . }`
	- `[[maybe_unused]]`
		뭔가 사용하지 않았을 때 컴파일러가 경고 메시지를 출력하지 않도록 설정하는 데 사용된다. ==단, 컴파일러 경고 수준이 높게 설정되어 있을 경우에만 이에 대한 경고를 출력한다.==
		`int function(int param1, [[maybe_unused]] int param2) { return 0; }`
		함수 내부에서 매개변수로 받아온 변수에 대해 아무런 연산처리가 없을 경우 발생되는 경고 메시지이다. 위와 같이 `[[maybe_unused]]` 어트리뷰트를 매개변수 앞에 선언할 경우 해당 매개변수에 한해서만 경고를 출력하지 않겠다는 어트리ㅠ트이다.
	- `[[noreturn]]`
		함수에 `[[noreturn]]` 어트리뷰트를 지정하면 호출 지점으로 다시 돌아가지 않는다. <font color="red">주로 프로세스나 스레드 종료와 같이 뭔가가 끝나게 만들거나, 익셉션을 던지는 함수가 여기에 해당한다.</font> 이 어트리뷰트를 이용하면 컴파일러가 특정한 경고나 에러 메시지를 출력하지 않게 만들 수 있다. 이 어트리뷰트를 지정하고 나면 그 함수의 용도에 대해 자세히 알게 되기 때문이다.
	- `[[likely]]`와 `[[unlikely]]`
		`[[likely]]`와 `[[unlikely]]` 어트리뷰트를 지정하면 컴파일러가 최적화 작업을 수행하는 데 도움을 줄 수 있다. 예를 들어 이 어트리뷰트를 이용하여 if와 switch 문에서 수행될 가능성이 높은 브랜치를 표시할 수 있다. 하지만 이 어트리뷰트가 필요한 경우는 드문데, 최신 컴파일러와 하드웨어는 브랜치 예측 능력이 상당히 뛰어나기 때문에 이런 어트리뷰트를 지정하지 않아도 알아서 잘 처리하기 때문이다. 하지만 성능에 민감한 부분 등과 같이 특정한 경우에는 컴파일러에 도움을 줄 수 있다.
```
if(value > 11) [[unlikely]]
{
}
else {}

switch(value)
{
	[[likely]] case 1:
		break;
	case 2:
		break;
	default:
		break;
}
```

- C 스타일 배열
	배열은 같은 타입의 값을 연달아 저장하며, 각 값은 배열에서 해당 위치를 이용해 접근한다. C++에서 배열을 선언할 때는 반드시 배열의 크기를 지정해야 하는데, 변수로 지정할 수는 없고 반드시 상수 또는 상수 표현식으로 지정해야 한다. 
>[!Note]
>C++에서 배열을 표현할 C 스타일 배열보다는 표준 라이브러리에서 제공하는 std::array나 std::Vector를 사용하는 것이 좋다.	

- std::array
	C++은 std::Array라는 고정 크기 컨테이너를 제공한다. 이 타입은 array 헤더 파일에 정의되어 있다. 본질은 C 스타일 배열 위에 한꺼풀 덮어쓴 것에 불과하다.
	std::array는 C 스타일 배열에 비해 장점이 많다. 항상 크기를 정확히 알 수 있고, 자동으로 포인터 캐스트(동적 형변환)하지 않아서 특정한 종류의 버그를 방지할 수 있고, 반복자(iterator)로 배열에 대한 반복문을 쉽게 작성할 수 있다.
	선언은 `std::array<int, 3> arr`와 같이 템플릿 안에 자료형과 크기를 지정해준다.
	C++은 CTAD(calss template argument deduction, 클래스 템플릿 인수 추론)이라는 기능을 제공한다. 이것은 템플릿 타입을 지정하지 않아도 된다는 것으로 `std::array arr { 1, 2, 3 };`으로도 선언할 수 있다.
>[!Note]
>C 스타일 배열과 std::array는 둘 다 크기가 컴파일 시간에 결정되어야 하며, 실행 시간에 늘어나거나 줄어들 수 없다.

- std::vector
	vector는 C스타일의 배열 대신 사용할 수 있는 훨씬 유연하고 안전한 컨테이너이다. 원소를 모두 담을 수 있도록 메모리를 확보하는 작업은 vector 내부에서 처리되기 때문에 프로그래머가 메모리 관리를 신경 쓸 필요가 없으며, vector 는 동적 컨테이너이다. 즉, 실행 시간에 원소를 추가하거나 삭제할 수 있다는 것이다.
	vector는 제너릭 컨테이너(generic container)다. 거의 모든 종류의 객체를 담을 수 있기 때문에 vector를 사용할 때에는 템플릿 자료형을 명시해 줘야 한다. 하지만 vector 또한 CTAD를 지원한다. 그래서 템플릿 자료형을 넣는 대신 초기화를 해줌으로써 컴파일러가 해당 vector의 자료형을 추론할 수 있다.

- std::pair
	utility 헤더에 정의된 std::pair 클래스 템플릿은 두 값을 하나의 변수에 묶는다. 각 값은 public 데이터 멤버인 first, second로 접근할 수 있으며, std::pair 또한 CTAD를 지원한다.

- std::optional
	optional 헤더에 정의된 std::optional은 특정한 타입의 값을 가질 수도 있고, 아무 값도 가지지 않을 수도 있다. 
	optional은 기본적으로 함수 매개변수에 전달된 값이 없을 수도 있는 상황에 사용된다. 또한 값을 리턴할 수도 있고, 그렇지 않을 수도 있는 함수의 리턴 타입으로 사용하기도 한다. 기존에 리턴 값이 없는 경우를 표현하기 위한 nullptr, end(), -1, EOF와 같은 특수한 값을 사용하지 않아도 된다. 또한 함수의 리턴값은 수행 결과의 성공 여부를 나타내는 부울 타입으로 표현하고, 실제 결과는 출력용 매개변수를 이용하여 함수의 인수에 전달하는 식으로 작성하지 않아도 된다.(이런 매개변수는 비 const 대상을 가리키는 레퍼런스 타입으로 선언한다.)
	optional 타입은 클래스 템플릿이므로 `std::optional<int>`와 같이 템플릿 자료형을 반드시 지정해줘야 한다.
	`std::optional<int> getData(bool data) { if ( data ) { return 0; } return nullopt; }`
	이렇게 작성된 함수는 `optional<int> data1 { getData(true) };`와 같이 호출한다.
	optional에 값이 있는지 확인하려면 has_value() 메서드를 사용하거나 호출을 받은 변수가 값을 담고있는지 아닌지로 조건문을 통해 알 수 있다.
	optional에 값이 있을 때는 value()나 역참조 연산자로 그 값을 가져올 수 있다.
	값이 없을 때 value()를 호출하면 std::bad_optional_access 익셉션이 발생한다.
	value_or(x) 함수를 사용하면 값이 있을때는 해당 값을, 없을 때는 매개변수로 받은 값을 리턴한다. 이때 레퍼런스는 optional에 담을 수 없다. 레퍼런스형의 템플릿 자료형 선언도 불가능하지만, 포인터는 가능하다.

- 구조적 바인딩
	구조적 바인딩을 이용하면 여러 변수를 선언할 때 array, struct, pair 등에 담긴 원소들을 이용하여 변숫값을 한꺼번에 초기화할 수 있다.
	`array values { 1, 2, 3 };`
	예를 들어 위와 같이 배열이 정의되어 있다고 했을 때, 이 상태에서 x, y, z 변수를 선언하려면 각 초긱값을 values 배열에서 담아서 초기화할 수 있다. 구조적 바인딩을 적용하려면 반드시 auto 키워드를 붙여야 한다. 
	`auto [x, y, z] { values };`
	구조적 바인딩에서 왼쪽에 나온 선언할 변수 개수와 오른쪽에 나온 표현식에 담긴 값의 개수는 반드시 일치해야 한다.
	구조적 바인딩은 배열뿐만 아니라 비 static 멤버가 모두 public으로 선언된 구조체에도 적용할 수 있다.
	이때 그냥 auto가 아닌 auto&나 const auto&를 이용하여 구조적 바인딩으로 비 const에 대한 레퍼런스나 const에 대한 레퍼런스를 생성할 수도 있다.

- 반복문
	iterator 반복문도 조건문들과 동일하게 초기자를 사용할 수 있다.

- 초기자 리스트
	초기자 리스트는 intializer_list 헤더 파일에 정의되어 있으며, 이를 활용하면 여러 인수를 받는 함수를 쉽게 작성할 수 있다. std::initializer_list 타입은 클래스 템플릿이다. 그러므로 템플릿 자료형을 선언해주어야 한다.
	`int function(initializer_list<int> values) { int result = 0;  for(int value : values) result += value; return result; }`
	`int a = function({1, 2, 3)};`
	초기자 리스트는 타입에 안전하다. 그러므로 초기자 리스트를 정의할 때 지정한 타입만 허용한다. 

- C++의 스트링
	C++에서 스트링을 다루는 방법은 두 가지이다.
	- C 스타일 : 스트링을 문자 배열로 표현
	- C++ 스타일 : C 스타일로 표현된 스트링을 쉽고 안전하게 사용할 수 있도록 스트링 타입으로 감싼 방식

- C++의 객체지향 언어 특성
	객체지향 프로그래밍(object-oriented programming, OOP) 에서는 코드 작성 방식이 기존과는 달리 직관적이다. 
	- 클래스 정의
		클래스는 객체의 특성을 정의한 것이다. 클래스는 데이터 멤버(속성)와 메서드(동작)로 구성된다. 각각의 데이터 멤버와 메서드는 public, protected, private 등으로 접근 수준을 지정한다. 
		- 생성자 : 클래스와 이름이 같고 리턴 타입이 없는 메서드. 클래스의 객체를 생성할 때 자동으로 호출된다.
		- 소멸자 : 생성자와 형태는 같지만 앞에 틸드(~)를 붙인 메서드. 객체가 제거될 때 자동으로 호출된다.
		- 생성자 초기자 : 생성자로 데이터 멤버를 초기화하는 방법 중 하나로, 함수 정의부에서 생성자 이름 뒤에 콜론을 붙여서 표현, const로 선언된 변수또한 생성자 초기자에서 초기화가 가능하다.
		- 클래스 내부 초기자 : 생성자 함수 내부에서 데이터 멤버를 초기화하는 방법.

- 스코프 지정
	변수, 함수, 클래스명과 같이 프로그램에 나오는 모든 이름은 저마다 스코프가 있다. 스코프는 네임스페이스, 함수 정의, 중괄호 블록, 클래스 정의 등으로 생성한다. 변수나 함수, 클래스 등에 접근할 때는 가장 안쪽 스코프에 있는 이름부터 검색하고, 거기에 없으면 바로 다음 바깥의 스코프를 검색하는 등 글로벌 스코프에 이르기까지 계속 진행한다. 네임스페이스나 함수, 중괄호로 묶은 블록, 클래스 등에 없는 이름은 모두 글로벌 스코프에 있다고 간주한다. 만일 글로벌 스코프에도 없을 경우 컴파일러는 에러를 발생시킨다.
	때로는 스코프 안에 있는 이름이 바깥 스코프에 있는 동일 이름에 가려질 수도 있다. 또한 현재 다루려는 스코프가 프로그램의 해당 라인에서 디폴트 스코프 지정 범위에 없는 경우도 있다. 어떤 이름이 디폴트 스코프 지정 범위에 적용되지 않게 하려면 그 이름 앞에 스코프 지정 연산자인 ::을 이용하여 원하는 스코프를 지정하면 된다.

- 균일 초기화
	C++11 이전에는 타입의 초기화 방식이 일정하지 않았다. 구조체 변수의 초기화에는 중괄호를 , 클래스 변수의 초기화에은 소괄호를 사용하여 생성자를 호출했다. 그런데 C++11부터 타입을 초기화할 때 전부 중괄호 문법을 사용하는 균일 초기화로 통일되었다.
	균일 초기화를 사용하면 축소 변환을 방지할 수 있다. C++에서는 암묵적 형변환을 통하여 축소 변환될 때가 있다. 하지만 균일 초기화를 사용하면 이러한 암묵적 형변환으로 인한 축소 변환을 허용하지 않기 때문에 버그가 발생할 확률을 줄일 수 있다.
	축소 변환 캐스트를 하려면 GSL(Guideline Support Library)에서 제공하는 gsl::narrow_case() 함수를 사용하면 된다.
	균일 초기화는 동적 할당 배열을 초기화할 때도 적용할 수 있다.
	또한 생성자의 초기자에서도 동일하게 사용할 수 있다.

- 지정 초기자
	C++20부터 지정 초기자(designated initializer)가 도입됬다. 이 초기자는 묶음 타입의 데이터 멤버를 초기화하는데 사용된다. 
	- 묶음 타입(aggregate type) : public 데이터 멤버만 갖고, 사용자 정의 생성자나 상속된 생성자가 없고, virtual 함수도 없으며 virtual, private, protected 베이스 클래스도 없는 배열 타입 객체나 구조체 객체, 클래스 객체를 의미한다. 
	지정 초기자는 점 뒤에 데이터 멤버의 이름을 적는 방식으로 표기한다. 지정 초기자에 나오는 데이터 멤버는 반드시 데이터 멤버가 선언된 순서를 따라야 한다. 지정 초기자와 비지정 초기자를 섞어 사용할 수는 없다. 지정 초기자로 초기화되지 않은 데이터 멤버는 모두 디폴트값으로 초기화된다.
	- 클래스 내부 초기자를 가진 데이터 멤버는 거기서 지정된 값을 갖게 된다.
	- 클래스 내부 초기자가 없는 데이터 멤버는 0으로 초기화된다.
```C++
struct Vector3
{
	int x, y, z;
}

Vector3 vec 
{
	.x = 10,
	.y = 20,
	.z = 30
};
```

- 포인터와 동적 메모리
	동적 메모리를 이용하면 컴파일 시간에 크기를 확정할 수 없는 데이터를 다룰 수 있다.
	- 스택과 프리스토어
		C++ 애플리케이션에서 사용하는 메모리는 크게 스택( stack)과 프리 스토어(free store, heap(?))로 나뉜다. 스택은 선입 선출 방식으로 제일 위에(현재) 실행중인 함수를 가리킨다. 현재 실행중인 함수에 선언된 변수는 모두 최상단 스택 프레임의 메모리 공간에 담긴다. 
		- 스택 : 스택 프레임은 각 함수마다 독립적인 메모리 공간을 제공한다는 점에서 굉장히 유용한데, 어떤 변수가 함수에 대한 스택 프레임 안에 선언되어 있다면 그 안에서 다른 함수를 호출하더라도 특별히 수정하지 않는 한 그 변수는 그대로 유지된다. 또한 호출된 함수가 실행이 끝나면 해당 스택 프레임이 삭제되기 때문에 그 함수 안에 선언된 변수가 더 이상 메모리 공간을 차지하지 않는다. 스택에 할당된 일반 변수는 직접 할당 해제할 필요 없이 자동으로 처리된다.
		- 프리 스토어 : 프리 스토어는 현재 함수 또는 스택 프레임과는 완전히 독립적인 메모리 공간이다. 함수가 끝난 후에도 그 안에서 사용하던 변수를 계속 유지하고 싶다면 프리 스토어에 저장한다. 프리 스토어는 비트 더미와 같아서 스택보다 구조가 간결하다. 프로그램에서 원하는 시점에 언제든지 이 비트 더미에 새로운 비트를 추가하거나 기존에 있던 비트를 수정할 수 있다.프리 스토어에 할당된 메모리 공간은 직접 할당 해제해야 한다. 프리 스토어는 스마트 포인터를 사용하지 않는 한 자동으로 할당 해제되지 않기 때문이다.(<font color="yellow">프리 스토어는 힙 메모리 공간을 의미하는 것 같다.</font>)
	- 