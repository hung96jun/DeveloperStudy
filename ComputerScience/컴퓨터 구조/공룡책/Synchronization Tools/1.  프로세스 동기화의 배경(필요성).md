- 상호 협력적 프로세스들(Cooperating Processes)의 특징
	- 상호 협력적인 프로세스들은 서로 영향을 주거나 받을 수 있다.
	- 상호 협력적인 프로세스들은 논리적인 주소 공간(대표적인 것이 쓰레드)을 공유하거나 공유 데이터를 공유한다. 공유 데이터 방식은 다음과 같은 방식이 있다.
		- 공유 메모리(Shared Memory) 방식 : 메모리 특정 영역에 여러 프로세스들이 지원을 공유할 수 있는 공간을 생성하고 자원을 공유하는 방식
		- 메시지 전송 방식(Message Passing) 방식 : 여러 프로세스들끼리 네트워크를 통해 링크를 연결하고 메시지를 주고 받는 방식이다.
- 상호 협력적 프로세스들의 문제
	- 상호 협력적인 프로세스들이 공유 데이터에 동시적으로 접근하는 것은 데이터 불일치(Data Inconsistency)가 발생할 수 있다.
	- 데이터 불일치를 해결하기 위한 방법
		- 데이터 불일치를 해결하기 위해서는 논리적인 주소 공간을 공유하는 상호 협력적 프로세스들의 순서가 있는 실행(Orderly Execution, 동기화)이 보장되어야 한다.
- 데이터 불일치가 발생하는 배경
	데이터 불일치가 발생하는 경우는 다음과 같이 여러 개의 프로세스들(또는 쓰레드들)이 실행하는 경우에 발생한다.
	- 동시 실행9Concurrent Execution, 동시성)
		- 어떤 한 프로세스가 실행하는 중에 인터럽트가 발생하고 CPU 코어의 제어권을 또 다른 프로세스에게 선점될 수 있다.
		- 선점한 다른 프로세스는 기존 프로세스가 접근하고 있는 공유 자원에 접근하여 값을 바꾸는 상황이 발생하여 데이터의 불일치가 발생할 수 있다.
	- 병렬 실행(Parallel Execution, 병렬성)
		- 병렬 실행이란 2개 이상의 CPU 코어를 통해 하나의 프로세스를 처리하는 것이다.
		- 병렬 실행의 대표적인 특징은 각각의 CPU 코어들이 하나의 프로세스를 실행한다는 점이다.
		- 하지만 병렬 실행 중 하나의 공유 자원을 CPU 코어를 할당받은 쓰레드들이 접근한다면 데이터 불일치가 발생할 수 있다.
- 동시성과 병렬성의 차이
	- 동시성
		동시성은 적어도 두 개의 쓰레드가 실행중일 때 존재하는 조건이며, 가상 병렬 처리의 한 형태로 시간 분할(Time-Slicing)을 포함한다. 즉, 가상 병렬 처리라는 의미는 CPOU 코어가 한 번에 하나의 명령어만을 처리한다는 의미이다. 두 개 이상의 알고리즘이 하나의 CPU 코어에서 스레드간에 빠르게 교차(문맥 교환, Context Switching)되면서 실행되기 때문에 '동시'라고 느끼는 것이다.
		정리하면 동시성은 하나의 CPU 코어 내에서 여러 프로세스(또는 쓰레드)들을 빠르게 교차하면서 한 번에 하나의 명령어만을 수행하는 방식이다. 동시성이라는 의미는 이러한 수행 속도가 너무나 빨라서 마치 동시에 수행되는 것처럼 느끼는 것이다.
		![[Pasted image 20240306082436.png]]
	- 병렬성
		병령ㄹ성의 수행 조건은 적어도 2개 이상의 CPU 코어가 있어야 한다. 병렬성의 수행 방식은 각각의 CPU 코어가 하나의 프로세스(또는 쓰레드)를 맡아서 실행한다는 점이다. 동시성과는 비슷하지만 핵심적인 차이점은 동시성의 수행 방식은 하나의 단일 CPU 코어 내에서 쓰레드들을 교차(문맥 교환, Context Switching)하면서 수행한다면 병렬성의 수행 방식은 교차하지 않고 각각의 쓰레드를 수행한다. 그러므로 두 개의 알고리즘이 정확히 같은 시점에 수행될 때 병렬적이라고 할 수 있다.
		![[Pasted image 20240306082732.png]]
- 데이터 불일치가 발생하는 사례 : 생산자-소비자 문제
	- 생산자는 유한한 길이를 가진 버퍼에 데이터를 생산하여 저장한다. 소비자는 버퍼에 데이터를 소비한다.
	- 공유자원은 데이터를 담는 버퍼 배열과 버퍼에 담긴 데이터의 개수를 표현하는 const 변수이다.
	- 생산자와 소비자 프로세스가 동시에 비동기적으로 공유 자원(buffer)에 접근할 때 데이터 불일치가 발생할 수 있다.
	![[Pasted image 20240306083049.png]]
	위 코드를 기반으로 생산자와 소비자 프로세스가 동시에 실행된다면 공유 자원을 업데이트하는 동안 생산자 또는 소비자가 선점하여 공유 자원의 값을 먼저 업데이트하여 데이터의 불일치가 발생할 수 있다.
	- 생산자-소비자 문제에서 데이터 불일치가 발생하는 과정
		![[Pasted image 20240306084015.png]]
		위 수행과정과 같이 생산자 또는 소비자가 버퍼와 count 변수에 접근하여 조작하는 과정에서 다른 프로세스(생산자, 소비자)가 현재 실행중인 프로세스를 선점하고 버퍼 또는 count 변수에 값을 업데이트 한다면 데이터 불일치가 발생할 것이다.
	- 생산자-소비자 문제에서 count 변수 데이터 불일치가 발생하는 이유
		count값이 잘못되는 이유는 "count++"  연산이 다음과 같은 기계어로 구현될 수 있기 때문이다.
		`register1 = count;`
		`register1 = register1 + 1;`
		`count = register1;`
		위에서 register1은 한 CPU만 접근할 수 있는 지역 레지스터이며, 마찬가지로 "count--"는 다음과 같이 구현될 수 있다.
		`register2 = count;`
		`register2 = register2 + 1;  // 감소 연산자인데 + 1연산?`
		`count = register2;`
		위 레지스터의 내용은 인터럽트 처리기에 의해 메모리에 잡시 보관되었다가 다시 적재된다.
		"count++"와 "count--"문장을 병행하게 실행하는 것은 앞에서 제시한 저수준의 문장들을 임의의 순서로 뒤섞어 순차적으로 실행하는 것과 동등하다.(그러나 각 고수준 문장 내에서의 순서는 유지됨) 그 중 하나는 다음과 같은 순서를 가질 수 있다.![[Pasted image 20240306090130.png|700]]
		위와 같이 count 변수에 register1, 2가 저장되기 전에 프로세스의 문맥 교환(Context Switch)이 발생하게 되면 count 변수는 부정확한 값이 저장된다.
		위와 같이 생산자-소비자 문제를 통해 생산자 프로세스와 소비자 프로세스가 수행중에 공유 자원을 얻기 위해 다른 프로세스를 선점하는 상태를 경쟁 상태(Rate Condition)이라고 한다.
- 경쟁 상태(Rate Condition)가 발생하는 조건
	- 여러 개의 프로세스(또는 쓰레드)가 존재하는 경우
	- 같은 공유 자원에 동시에 접근하고 갱신하는 경우
	위와 같은 조건에서 여러 개의 프로세스가 접근한 결과는 공유 자원에 접근하는 프로세스들의 순서에 달려 있다.
- 경쟁 상태를 막기 위한 방법
	오직 한 순간에 하나의 프로세스만이 고유 자원에 접근해야 한다.