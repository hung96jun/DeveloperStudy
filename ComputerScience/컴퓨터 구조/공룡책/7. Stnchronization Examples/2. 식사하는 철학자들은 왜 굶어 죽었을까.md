1. 동기화 문제의 대표적 문제 : 식사하는 철학자들 문제
	![[Pasted image 20240324221259.png]]
	- 5명의 철학자들은 생각하기(thinking), 먹기(eating) 두 가지 행동만을 반복한다.
	- 5명의 철학자들은 한짝밖에 없는 5개의 젓가락을 공유한다.
	- 철학자들이 배고파지면 배고픈 철학자의 양 옆에 있는 두 젓가락을 집어들어 밥을 먹는다.
	- 한 명의 배가 고픈 철학자가 그 양 옆에 있는 젓가락을 집고 밥을 먹을 때 그 철학자는 젓가락을 내려놓지 않고 먹는다.
	
	- 식사하는 철학자들의 문제점
		- 교착 상태가 없고 기아 현상이 없는 여러 개의 프로세스들(철학자들) 사이에서 여러 개의 자원(젓가락)의 할당이 필요하다.
		- 여기서 각각의 철학자들의 프로세스들은 전부 동일한 성격의 프로세스들이 아닌 네트워크 소켓 프로세스가 될 수 있고 파일 프로세스일 수 있다.
		- 각각의 젓가락의 자원들은 철학자들과 마찬가지로 자원의 성격이 다를 수 있다.
	- 식사하는 철학자들 해결안 방법 : 세마포어(Semaphore)
		- 세마포어 해결안은 각각의 젓가락이 세마포어를 설정하는 것이다.
		- 한 철학자는 wait() 연산을 수행함으로써 대기하다가 젓가락을 얻는다.
		- 젓가락을 얻은 철학자가 밥을 다 먹은 후 signal() 연산을 호출하여 젓가락은 놓는다.
	- 세마포어 해결안의 문제점 : 교착 상태(DeadLock)과 기아(Starvation)
		- 교착 상태 발생 시나리오
			1. 다섯 명의 철학자가 동시에 배가 고플 때
			2. 각각의 철학자들은 모두 왼쪽 젓가락을 집은 다음 오른쪽 젓가락을 집을 때
			3. 1번->2번 순서로 실행이 된다면 모든 철학자는 왼쪽 젓가락을 잡은 채로 오른쪽 철학자가 오른쪽 젓가락을 놓고자 대기하게 되고 이는 교착 상태가 발생한다.
		- 교착 상태 문제의 해결안
			1. 철학자들의 인원수를 젓가락의 개수보다 1명 적게 배치
				- 모든 철학자들이 젓가락을 왼쪽을 집었더라도 하나의 젓가락은 남기 때문에 반드시 1명의 철학자는 밥을 먹고 젓가락을 내려 놓을 수 있다.
			2. 철학자들은 두 젓가락을 집을 수 있을 때에만 젓가락을 집는 것을 허락한다.
			3. 비대칭적 해결안 사용
				- 홀수 번호를 부여 받은 철학자들은 왼쪽 젓가락을 집은 다음 오른쪽 젓가락을 집는다.
				- 짝수 번호를 부여 받은 철학자들은 오른쪽 젓가락을 집은 다음 왼쪽 젓가락을 집는다.
				- 상호 배제 보장으로 인해 두 철학자가 동시에 젓가락을 집는 것을 허용하지 않기 때문에 이 해결안을 사용할 수 있다.
		- 교착 상태 문제 해결안의 한계점
			상호 배제와 교착 상태를 해결하더라도 기아(Starvation) 현상을 해결하지는 못한다.
		
		- 식사하는 철학자들 해결안 방법 : 모니터(Monitor)
			- 철학자들은 왼쪽 젓가락, 오른쪽 젓가락 두 개 다 이용 가능할 때에만 젓가락을 집는다.
			- 철학자들의 3가지 상태를 구별할 필요가 있다.
				- 생각하는 상태(thinking)
				- 배고픈 상태(hungry)
				- 먹는 상태(eating)
			- 철학자는 이웃하는 두 젓가락이 eating상태가 아닌 경우에만 hungry 상태에서 eating 상태로 전환할 수 있다.
			- 모니터를 사용하기 위해서는 조건 변수(Condition Variable)이 필요하다.
				- 조건 변수는 철학자가 배가 고프고 철학자가 원하는 젓가락을 얻지 못할 때 철학자 스스로 대기하는 것을 허용하게 한다.
		- 모니터를 활용한 식사하는 철학자들의 해결안
			- 젓가락들의 분배는 모니터에 의해서 제어된다.(Dining Philosopher Monitor)
			- 각각의 철학자는 먹기 전에 pick() 연산을 호출해야 하고 다 먹은 후 putdown() 연산을 호출해야 한다.
			- pick() 연산을 호출할 때 젓가락을 얻지 못하면 대기해야 한다.
		- 모니터를 활용한 해결안의 한계점
			- 상호 배제(Mutal Exclusion)과 교착 상태(DeadLock) 해결은 보장하지만 기아(Starvation) 상태는 여전히 발생 가능성이 존재한다.
			- 한 철학자가 배가 고파 젓가락을 집고자 해도 다른 철학자가 계속 빠르게 선점하여 젓가락을 집는다면 철학자는 굶어 죽을 수 있다.
2. 대체적인 접근 방법들
	- 쓰레드-안전(Thread-Safe) 동시성 애플리케이션
		- 동시성 애플리케이션은 멀티 코어 시스템에서 뮤텍스 락, 세마포어, 모니터와 같은 기술을 사용하여 좋은 성능을 발휘한다. 그러나 경쟁 상태(Race Conditions)와 liveness hazards(교착 상태)같은 상황에 빠져버리는 위험이 증가한다.
		- 쓰레드-안전 동시성 애플리케이션의 설계를 위한 대체적인 접근 방법들
			- 트랜잭션 메모리(Transactional Memory)
				- 트랜잭션이란 원자적인 실행의 단위를 의미한다.
				- 메모리 영역 자체를 트랜잭션 자체로 만들자는 의미이다.
			- OpenMP
				- OpenMP란 공유 메모리 환경에서 프로그램을 병렬화 해주는 표준이다.
				- OpenMP 표준은 컴파일러 지시자의 집합을 정의하고 지시자는 컴파일러에게 코드의 블럭을 어떻게 처리할 지 알려준다.
				- OpenMP를 이용하면 코드의 특정 영역을 임계 구역으로 선언하여 해당 구역을 임계 영역으로 만들어 준다.
			- 함수형 프로그래밍 언어(Functional Programming Language)
				- 함수형 프로그래밍 언어를 사용하여 명령형 프로그래밍 언어에서 발생하는 동기화 문제를 원천적으로 막는다.
				- 함수형 프로그래밍 언어는 스칼라, 하스켈 등이 있다.
