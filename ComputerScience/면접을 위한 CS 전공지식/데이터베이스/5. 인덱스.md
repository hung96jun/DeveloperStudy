- 인덱스의 필요성
	인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치이다.
- B-트리
	인덱스는 보통 B-트리라는 자료 구조로 이루어져 있다. 이는 루프 노드, 리프 노드, 그리고 루트 노드와 리프 노드 사이에 있는 브랜치 노드로 나뉜다.
	![[Pasted image 20240101202838.png]]
	예를 들어 E를 찾는다고 하면 전체 테이블을 탐색하는 것이 아닌 E가 있을 법한 리프 노드로 들어가서 E를 탐색하면 쉽게 찾을 수 있다. 이 자료 구조 없이 E를 탐색하고자 하면 순차 탐색을 해야 하지만, 이렇게 노드들로 나누면 두 번만에 리프 노드에서 찾을 수 있다.
	![[Pasted image 20240101203517.png]]
	트리 탐색은 맨 위 루트 노드부터 탐색이 일어나며 브랜치 노드를 거쳐 리프 노드까지 내려온다. 'value 보다 같거나 클 때까지 <='를 기반으로 처음 루트 노드에서는 부터 자식 노드들을 타고 내려와 리프 노드에 정렬된 값을 기반으로 탐색하게 된다. 이렇게 루트 노드부터 시작하여 마지막 리프 노드에 도달해서 value가 가리키는 데이터 포인터를 통해 결과값을 반환하게 된다.
	- 인덱스가 효율적인 이유와 대수확장성
		인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문이다.
		대수확장성이란 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미한다. 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가한다.
		
| 트리 깊이 | 인덱스 항목의 수 |
| ---- | ---- |
| 3 | 64 |
| 4 | 256 |
| 5 | 1024 |
| 6 | 4096 |
| 7 | 16384 |
| 8 | 65536 |
| 9 | 262144 |
| 10 | 1048576 |
- 인덱스 만드는 방법
	- MySQL
		MySQL의 경우 클러스터형 인덱스와 세컨더리 인덱스가 있으며, 클러스터형 인덱스는 테이블당 하나를 설정할 수 있다. primary key 옵션으로 기본키로 만들면 클러스터형 인덱스를 생성할 수 있고, 기본키로 만들지 않고 unique not null 옵션을 클러스터형 인덱스로 만들 수 있다.
		create index . . . 명령어를 기반으로 만들면 세컨더리 인덱스를 만들 수 있다. 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스를 만드는 것보다 성능이 좋다.
		세컨더리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 대 생성해야 하는 인덱스이다.
	- MongoDB
		MongoDB의 경우 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정된다. 그리고 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스로 설정할 수 있다.
- 인덱스 최적화 기법
	인덱스 최적화 기법은 데이터베이스마다 조금씩 다르지만 기본적인 골조는 똑같기 때문에 특정 데이터베이스를 기준으로 설명해도 무방하다.
	- 인덱스는 비용이다
		먼저 인덱스는 두 번 탐색하도록 강요한다. 인덱스 리스트, 그 다음 컬렉션 순으로 탐색하기 때문이며, 관려 닝ㄺ기 비용이 들게 된다.
		또한, 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다. 이때 B-트리의 높이를 균형있게 조절하는 빕용도 들고, 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 들게 된다.
		그렇기 때문에 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 답이 아니다. 또한, 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적이다.
	- 항상 테스팅하라
		인덱스 최적화 기법은 서비스 특징에 따라 달라진다. 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 대문이다. 그렇기 때문에 항상 테스팅하는 것이 중요하다. explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 한다.
	- 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.
		보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다. 같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 한다.
		1. 어떠한 값과 같음을 비교하는 \==이나 eqqual 이라는 쿼리가 있다면 제일 먼저 인덱스로 설정한다.
		2. 정렬에 사용되는 필드라면 그 다음 인덱스로 설정한다.
		3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 \>이거나 \< 등 많은 값을 출력해야 하는 쿼리에 사용하는 필드라면 나중에 인덱스를 설정한다.
		4. 유니크한 값의 정도를 카디널리티라고 한다. 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 한다. 예를 들어 age와 emal이 있다고 했을 때 email이 더 높기 때문에 email이라는 필드에 대한 인덱스를 먼저 생성해야 하는 것이다.