1. 프로그램의 구조와 인터럽트
	컴퓨터 프로그램은 어떠한 프로그래밍 언어로 작성되었든 그 내부 구조는 함수들로 구성된다.
	프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다.
	- 주소 영역
		- 코드(Code) 영역
			사용자가 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령(Machine Instruction) 형태로 변환되어 저장되는 공간
		- 데이터(Data) 영역
			전역 변수(Global Variable) 등 프로그램이 사용하는 데이터를 저장하는 공간
		-  스택(Stack) 영역
			함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데에 사용되는 공간
		- 힙(Heap) 영역
			런타임에 결정되는 메모리 영역으로, 동적 할당 변수가 저장되는 공간. 단, 사용 후 반드시 해제해야 하면 해제하지 않을 경우 Memory Leak 현상이 발생
	- 함수의 호출과 인터럽트 동작 원리
		- 함수는 스택, 인터럽트는 프로세스 제어 블록에 저장
		- 둘의 작동 원리는 비슷하다
	- 함수의 호출
		- X 함수가 수행 중에 Y 함수를 호출한 경우 프로그램은 X 함수에서 Y 함수를 호출한 지점을 스택에 저장한다.
		- 함수가 수행된 후 스택에 저장된 주소 위치로 돌아와 X 함수를 계속 수행
		- 함수가 호출되면 다음에 실행할 명령(Instruction)의 메모리 위치가 변경된다.
	- 인터럽트
		- A 프로그램이 CPU를 할당 받고 명령 수행 도중 인터럽트가 발생
		- A는 혅재 수행중인 명령의 위치를 프로세스 제어 블록에 저장
		- 인터럽트 처리 루틴으로 넘어가서 인터럽트 처리
		- A의 저장된 작업 지점부터 이어서 실행
2. 컴퓨터 시스템의 작동 개요
	- 프로그램 카운터(Program Counter : PC)
		CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터
		- 조건문, 반복문, 함수 호출 등에 의한 주소 이동이 없는 이상 코드가 순차적으로 수행
	- 컴퓨터 시스템 구성
		- 컴퓨터의 시스템을 구성하는 하드웨어
			- CPU와 메모리
		- 입출력 장치와 이들을 전담하는 작은 CPU와 메모리
			- 입출력 컨트롤러와 로컬 버퍼
		- ![[Pasted image 20240220175825.png]]
3. 프로그램의 실행
	- 프로그램의 실행(Program Execution)
		- 디스크에 존재하던 실행 파일이 메모리에 적재
		- 프로그램이 CPU를 할당받고 명령(Instruction)을 수행
		- ![[Pasted image 20240220175924.png]]
		- 프로세스의 주소 공간은 코드, 데이터, 스택 등으로 구성
		- 각 프로그램마다 이러한 주소 공간을 가짐
			- 가상 메모리(Virtual Memory) 또는 논리적 메모리(Logical Memory)
			- 실제 물리적 메모리의 주소와 독립적으로 각 프로그램마다 독자적인 주소 공간을 가진다.
		- 운영체제도 프로그램이므로 운영체제 커널의 주소 공간도 코드, 데이터, 스택으로 구성
	- 커널의 코드 영역
		- CPU, 메모리 등의 자원을 관리하기 위한 부분
		- 사용자에게 편리한 인터페이스를 제공하기 위한 부분
		- 시스템 콜 및 인터럽트를 처리하기 위한 부분
	- 커널의 데이터 영역
		- CPU와 메모리같은 하드웨어 자원 및 수행 중인 프로그램을 관리하기 위한 자료구조 저장
		- 하드웨어와 소프트웨어를 포함하는 시스템 내의 모든 자원을 관리하기 위한 자료구조 유지
	- 프로세스(Process)
		프로세스란 현재 수행중인 프로그램
		- 각 프로세스의 상태, CPU 사용 정보, 메모리 사용정보 등을 유지하기 위한 자료구조인 PCB가 있다.
	- 커널의 스택 영역
		프로그램이 자기 자신의 코드 내에서 함수 호출 및 복귀 주소를 유지하기 위해서는 자기 주소 공간 내의 스택 사용.
		시스템 콜이나 인터럽트 등으로 운영체제의 코드가 실행되는 중에 함수 호출이 발생할 경우 커널 스택 사용
		- 함수 호출시의 복귀 주소를 저장하기 위한 용도로 사용
		- 현재 수행 중인 프로세스마다 별도의 스택을 두어 관리
			- 프로세스가 함수를 호출할 때 자기 주소 영역 내부에 정의된 함수를 호출하면 자신의 스택에 복귀 주소를 저장
			- 프로세스가 특권 명령을 수행하려고 커널에 정의된 시스템 콜을 호출하고 시스템 콜 내부에서 다른 함수를 호출하는 경우 복귀 주소는 커널 내의 주소가 되어 사용자 프로그램의 스택과는 별도의 저장 공간 필요
		- 커널은 일종의 공유 코드로 모든 사용자 프로그램이 시스템 콜을 통해 커널의 함수 접근이 가능
			- 일관성 유지를 위해 각 프로세스마다 커널 내에 발도의 스택을 둠
		- ![[Pasted image 20240220180649.png]]
4. 사용자 프로그램이 사용하는 함수
	- 사용자 정의 함수
	- 라이브러리 함수
		- sin(), printf()
	- 커널 함수
		- 시스템 콜 함수, 인터럽트 처리 함수
		- read(), write()

|  | 사용자 정의 함수 | 라이브러리 함수 | 커널 함수 |
| ---- | ---- | ---- | ---- |
| 정의 | 프로그래머 본인이 직접 작성한 함수 | 이미 누군가 작성해놓은 함수를 호출만 하여 사용하는 함수 | 커널의 코드에 정의된 함수 |
| 종류 | - | - | 시스템 콜 함수, 인터럽트 처리 함수 |
| 저장 공간 | 사용자 프로그램의 코드 영역 | 사용자 프로그램의 코드 영역 | 운영체제 커널의 주소 공가 |
| 함수 호출시 사용하는 스택 | 사용자 프로그램의 주소 공간에 있는 스택 | 사용자 프로그램의 주소 공간에 있는 스택 | 커널의 스택 |
| 실행 과정 | 사용자 프로그램 내에 존재하는 코드 실행 | 사용자 프로그램 내에 존재하는 코드 실행 | 운영체제에 CPU를 넘겨서 실행 |
| 함수 예시 | taeleebabo(), kido_calm_down() | sin(), printf() | read(), write() |
5. 인터럽트
	CPU는 매번 프로그램 카운터가 가리키고 있는 지점의 명령을 하나씩 수행 후 다음 명령 수행 직전에 인터럽트 라인이 세팅되었는지 확인
	인터럽트 발생시 현재 수행중이던 프로세스 중단 후 운영체제의 인터럽트 처리 루틴으로 이동해 인터럽트 처리
	- 인터럽트 처리 중에 또 다른 인터럽트 발생
		- 원칙적으로는 인터럽트 처리 중에 또 다른 인터럽트가 발생한 것 허용 안함
			- 데이터의 일관성이 유지되지 않기 때문
			- 인터럽트를 처리하는 중에 운영체제 커널에 정의된 데이터를 변경하고 있는데 다른 인터럽트가 발생해 앞선 인터럽트에서 변경 중이던 데이터를 또 다시 변경하게 되면 두 인터럽트에 의해 데이터가 원래 의도하지 않았던 결과값으로 변경될 수 있기 때문
			- ![[Pasted image 20240220181706.png]]
		- 예외
			현재 처리중인 인터럽트보다 더 시급하거나 CPU를 당장 사용해야 하는 경우
			- 인터럽트마다 중요도가 상이
			- 중요도가 더 높은 인터럽트가 발생하는 것을 허락
			- 이 경우 현재 처리 중인 인터럽트 코드 수행 지점을 저장 후 우선순위가 높은 인터럽트를 먼저 처리
6. 시스템 콜
	자신의 주소 공간을 거스르는 영역(커널)에 존재하는 함수를 호출하고, 스스로 인터럽트 라인에 인터럽트를 세팅을 하며, 그외엔 일반적인 인터럽트의 발생과 동일하다. ![[Pasted image 20240220181933.png]]
	- 시스템 콜 사용의 예(ex -  디스크의 파일 입출력)
		- 사용자 프로그램이 CPU에서 명령 수행 중 디스크 파일을 읽어와야 해서 시스템 콜로 커널 함수를 호출
		- 사용자 프로그램은 인터럽트 라인을 세팅
		- CPU는 다음 명령을 수행하기 전에 인터럽트가 발생했는지 점검
		- 인터럽트를 인지하면 현재 수행 중인 사용자 프로그램이 중단
		- CPU의 제어권을 운영체제에 이양
		- 운영체제는 설정된 인터럽트 라인으로 이번 인터럽트가 입출력 요청 인터럽트임을 인지
		- CPU는 디스크 컨트롤러에게 파일을 읽어오라 명령
		- 디스크 컨트롤러가 데이터를 읽어오는 동안 CPU는 다른 프로세스에게 제어권을 이양
		- 다른 프로세스가 CPU에서 명령 수행 중 입출력이 작업이 완료되면 디스크 컨트롤러가 CPU에게 인터럽트 발생
		- CPU는 사용자 프로세스 중단 후 인터럽트 처리 루틴으로 제어권을 이양(하드웨어 인터럽트)
		- 디스크로부터 로컬 버퍼로 읽어온 내용을 컴퓨터 내의 메모리로 복사
		- 디스크 입출력을 요청했던 프로세스에게 다시 CPU를 획득할 수 있는 권한을 허락
		- 해당 프로세스는 CPU를 기다리는 큐에 삽입
		- CPU 제어권은 인터럽트를 당항 프로세스에게 이양해 작업을 마저 수행
7. 프로세스의 두 가지 실행 상태
	- 사용자 모드에서의 실행 상태(User Mode Running)
		프로세스가 자신의 주소 공간에 정의된 코드를 실행
	- 커널 모드에서의 실행 상태(Kernel Mode Running)
		프로세스가 커널의 시스템 콜 함수를 실행
	![[Pasted image 20240220201106.png]]
	- 시스템 콜을 통해 실행되는 것이 프로세스의 코드가 아닌 운영체제 커널의 코드여도 프로세스가 실행 상태에 있다고 지칭(커널이 실행 상태에 있다 X)
	- 프로세스가 커널 모드에서 실행중