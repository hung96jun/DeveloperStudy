1. 컴퓨터 시스템의 구조
	- 입출력
		1. 외부 장치에서 내부 장치로 데이터를 읽어옴 -> input(입력)
			- 키보드 입력 받음
			- 디스크 내용 읽음
		2.  각종 연산 수행
		3. 그 결과를 외부 장치로 내보냄 -> output(출력)
			- 디스크에 데이터 저장
			- 모니터에 결과 출력
	- 내부 장치
		- CPU
		- 메모리
	- 외부 장치(입출력 장치)
		- 디스크
		- 키보드
		- 마우스
		- 모니터
		- 네트워크 장치
	- 컨트롤러
		각 하드웨어 장치에 존재하며 이들을 제어하는 작은 CPU
		- 메모리 컨트롤러
		- 디스크 컨트롤러
2. CPU 연산과 I/O 연산
	입출력 장치들의 I/O 연산은 입출력 컨트롤러가 담당, 컴퓨터 내에서 수행되는 연산은 메인 CPU가 담당
	- 로컬 버퍼(Local Buffer)
		디스크나 키보드 등에서 데이터를 읽어와서 로컬 버퍼에 데이터 임시 저장 후 메모리에 전달
		- 장치에서 로컬 버퍼로 읽어오는 일은 컨트롤러가 담당
	- 인터럽트(Interrupt)
		CPU에 알려줄 필요가 있는 이벤트가 일어난 경우 컨트롤러가 발생 시키는 것
		- 키보드 입력 혹은 요청된 디스크 입출력 작업의 완료 등
	- 인터럽트 라인(Interrupt Line)
		CPU 옆에서 인터럽트가 발생하면 CPU에게 신호
		- CPU는 신호가 들어오면 다음 명령 수행 전에 인터럽트 처리
			- 현재 명령은 완료 후 인터럽트 처리
3. 인터럽트의 일반적 기능
	- 운영체제 커널
		- 인터럽트가 들어왔을 때 해야 할 일이 프로그래밍되어 보관(인터럽트 처리 루틴)
		- 하드웨어 및 소프트웨어 자원 관리
		- 사용자 프로그램에 필요한 서비스 제공
	- 인터럽트 처리 루티(Interrupt Service Routine)
		- 다양한 인터럽트에 대해 각각 처리해야 할 업무들 정의
		- 인터럽트 핸들러(Interrupt Handler)라고도 불림
		- 인터럽트 처리 후 돌아갈 위치 저장
	- CPU
		- 디스크 컨트롤러가 인터럽트 발생했을 때 CPU는 인터럽트 처리 루팅 참조해서 수행
			- 디스크의 로컬버퍼에 있는 내용을 사용자 프로그램의 메모리로 전달
			- 해당 프로그램이 CPU를 할당받을 경우 다음 명령을 수행할 수 있음을 표시
	- 인터럽트 라인 세팅
		- 하드웨어 잍너럽트는 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅
		- 소프트웨어 인터럽트는 소프트웨어가 CPU의 인터럽트 라인을 세팅
	- 인터럽트 벡터(Interrupt Vector)
		- 운영체제가 할 일을 쉽게 찾도록 하는 것
		- 인터럽트 종류마다 번호를 정해 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키고 있는 자료구조
	- 소프트웨어 인터럽트
		- 소프트웨어 인터럽트는 Trap이라 불림
			- 인터럽트는 보통 하드웨어 인터럽트를 지칭
			- 사용자 프로세스로부터 CPU의 제어권이 운영체제에 이양되어 처리
			- 프로그램 코드가 직접 인터럽트 라인을 세팅하는 명령을 실행해 인터럽트 발생 후 제어권이 넘어감
			- 넓은 의미의 인터럽트 범주에 포함
			- ex) 예외상황, 콜
		- 예외상황(Exception)
			- 비정상적이거나 권한이 없는 작업을 시도할 때 이에 대한 처리를 위해 발생시키는 인터럽트
				- 사용자 프로그램이 0으로 나누는 연산 등 비정상적인 작업을 시도
				- 자신의 메모리 영역 바깥에 접근
		- 콜(System Call)
			- 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법
				- 사용자 프로그램에 정의되지 않고 운영체제 커널에 있는 코드 실행시
					- 인터럽트 라인 세팅을 통해 CPU 제어권을 운영체제로 넘겨 실행
					- 입출력을 수행하는 코드 작성 대신 이미 존재하는 커널의 코드를 호출해 처리
4. 인터럽트 핸들링(Interrupt Handling)
	인터럽트가 발생한 경우 처리해야 할 일의 절차, 운영체제는 인터럽트가 발생할 때에만 실행(CPU 제어권 획득). 그럼에도 운영체제는 컴퓨터 시스템 내의 모든 하드웨어 및 소프트웨어 자원을 체계적이고 효율적으로 관리
	- 세부 절차
		- 프로그램 A가 실행되는 도중 인터럽트 발생시
			1. A의 실행 상태를 PCB에 저장
			2. CPU의 제어권이 인터럽트 처리루틴으로 넘어감
			3. 인터럽트 처리가 끝나면 저장된 상태를 PCB로부터 CPU상에 복원
			4. 인터럽트 당하기 직전의 위치부터 실행
	- 레지스터(Register)
		- CPU 내부의 임시 기억 장치
		- CPU에서 명령이 실행될 때 레지스터에 데이터를 읽거나 쓰면서 작업
		- 새로운 명령 실행시 기존의 레지스터 값 삭제
	- 프로세스 제어 블록(Process Control Block : PCB)
		- 시스템 내에서 실행되는 프로그램들을 관리하기 위한 운영체제의 자료구조
			- 각각의 프로그램마다 하나씩 존재
		- 해당 프로그램의 어느 부분이 실행 중이었는지 저장
			- 실행 중이던 코드의 메모리 주소
			- 레지스터 값
			- 하드웨어 상태 등
5. 입출력 구조
	컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고 받는 것. 보통 동기식 입출력을 사용하며 큐를 통한 관리로 동기성을 보장한다.
	- 동기식 입출력(Synchronous I/O)
		프로그램이 입출력 요청을 했을 때 입출력 작업이 완료된 후, 그 프로그램이 후속 작업을 수행할 수 있는 방식
		- CPU는 입출력 연산이 끝날 때까지 인터럽트를 기다리며 자원 낭비
		- CPU의 명령 수행 속도는 빠름
		- 입출력 장치에서 데이터를 읽어오는 등의 입출력 연산은 상대적으로 느림
	- CPU를 다른 프로그램에 이양
		- 한 프로그램이 입출력 수행 중인 경우 CPU를 다른 프로그램에게 이양
			- CPU가 계속 쉬지 않고 일할 수 있도록 관리
		- 운영체제는 프로그램을 몇 가지 상태로 나눈다.
			- 입출력 중인 프로그램은 봉쇄 상태(Blocked State)로 전환
			- 봉쇄 상태의 프로그램에게는 CPU 할당 X
		- 동기식이지만 다수의 입출력 연산이 동시에 요청되거나 처리됨
	- 큐(Queue)
		- 여러 프로그램에게 CPU를 이양한 경우 여러 프로그램이 동일한 곳에서 접근해서 충돌 위험
		- 입출력 요청의 동기화를 위해 장치별로 큐를 두어 일르 방지
			- 프로그램 A가 먼저 요청했으면 이를 먼저 큐에 넣고 그 후에 발생한 B의 요청을 A의 요청 뒤에 삽입
			- 디스크는 큐에 있는 순서대로 처리해 동기성(Synchronization)을 보장
	- 큐헤더
		- 장치마다 큐 헤더로 큐 관리
		- 컨트롤러의 수행 속도나 장치 자체의 작업 수행 능력은 CPU에 비해 매우 떨어진다.
			- 입출력이 완료될 때까지 CPU가 입출력과 관련 없는 프로그램을 수행하도록 하고 인터럽트로 입출력 연산 완료를 전달![[Pasted image 20240213045154.png]]
	- 비동기식 입출력
		입출력 연산을 요청한 후에 CPU의 제어권을 입출력 연산을 호출한 프로그램에게 곧바로 다시 부여![[Pasted image 20240213160638.png]]
		- 이전 작업이 완료되어야만 다음 작업을 수행할 수 있는 경우 입출력이 완료된 후에 수행
		- 이전 작업과 다음 작업이 관계없다면 입출력 연산 완료와 무관하게 처리 가능한 작업부터 처리
	- 입출력 구조 예시
		1. 프로그램 A가 실행 중에 디스크에서 어떤 데이터를 읽어로아는 명령을 받음
		2. A는 시스템 콜을 통해 CPU에게 소프트웨어 인터럽트 발생
		3. CPU는 실행하던 A코드를 멈추고 현재 상태 저장
		4. CPU는 인터럽트에 의해 처리해야 할 커널의 루틴으로 이동
		5. CPU는 컨트롤러에게 입출력 연산 요청
		6. 컨트롤러는 A가 요청한 데이터를 디스크로부터 자신의 로컬 버퍼로 읽어옴
		7. 해당 과정 중 운영체제는 A를 봉쇄 상태로 표시해 A는 CPU 할당 불가
		8. 운영체제는 CPU를 다른 프로그램 B에 할당해 CPU 가동
		9. 원하는 정보가 로컬 버퍼로 다 들어오면 컨트롤러는 CPU에게 인터럽트 발생(하드웨어)
		10. CPU는 수행하던 프로그램 B 작업 지점 및 상태 저장 후 인터럽트 처리
		11. 로컬 버퍼에 있는 A가 요청한 데이터를 A의 메모리 영역으로 읽어옴
		12. A의 봉쇄 상태를 해제시켜 A에게 CPU 할당해도 되게 표시
		13. A는 CPU 큐에 대기
		14. CPU는 원래 수행하던 프로그램 B 지점으로 돌아가 업무를 이어서 수행
		15. A는 큐에서 대기하다가 차례가 되면 CPU 할당받고 입출력 연산 후 작업 수행
6. DMA
	메모리는 CPU에 의해서만 접근 가능한 장치, CPU 외의 장치는 CPU에게 인터럽트를 발생시켜 메모리에 접근이 가능하다.
	- 비효율성 해결
		- 모든 메모리 접근 연산이 CPU에 의해서만 이루어질 경우 입출력 장치가 메모리 접근을 원할 때마다 인터럽트에 의해 CPU 업무 방해
			- CPU 사용 효율성 Down
			- 비효율성 극복을 위해 메모리 접근이 가능한 장치 DMA(Direct Memory Access) 추가
		- 역할
			- 일종의 컨트롤러
			- CPU가 입출력 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 방지
			- 로컬 버퍼에서 메모리로 읽어오는 작업을 CPU 대신 대행
				- byte 단위가 아닌 블록(block)이라는 큰 단위로 메모리를 읽음
					- CPU를 효율적으로 관리
					- 빠른 입출력 연산 수행이 가능
7. 저장 장치의 구조
	- 주 기억 장치
		- 보통 메모리라 불리는 것
		- 주로 휘발성(Volatile)의 RAM을 매체로 사용
		- 크기 한정
		- 상대적으로 비싼 가격
		- 적은 용량
	- 보조 기억 장치
		- 주로 비휘발성(NonVolatile)의 마그네틱 디스크 사용
			- 전원이 꺼져도 저장된 내용을 기억
		- 플래시 메모리, CD, 마그네틱 테이프 등도 사용됨
		- 용도
			- 파일 시스템(File System)용
				전원이 꺼져도 유지되어야 하는 정보를 파일 형태로 보조 기억 장치에 저장
			- 스왑 영역(Swap Area)용
				스왑 영역은 메모리의 연장 공간
				- 다수의 프로그램이 동시 수행되는 경우 메모리 공간이 부족하게 됨
				- 운영 체제는 프로그램 수행에 당장 필요한 부분만 메모리에 올려둔다.
					- 그 외는 디스크의 스왑 영역에 내려놓는다.(승왑 아웃(Swap Out))
	- 하드 디스크
		보조 기억 장치 중 가장 대표적인 저장 먀ㅐ체
		- 여러 개의 마그네틱 원판들이 존재
		- 암(Arm)이 이동하며 원파에 저장된 데이터를 읽고 쓰는 방식
		- 디스크 원판의 표면은 트랙(Track)으로 나뉨
		- 각 트랙은 섹터(Sector)로 나뉨
		- 섹터에 최소한의 단위 정보 저장
8. 저장장치의 계층 구조
	- 빠른 / 느린 저장 장치
		- 빠른 저장 장치로부터 느린 저장 장치까지 단계적인 계층 구조
		- 당장 필요한 정보는 빠른 저장 장치에 넣어 수행 속도 상승
	- 빠른 저장 장치
		- 높은 단위 공간당 가격
	- 느린 저장 장치
		- 저렴한 가격
		- 대용량 사용
		- 느린 접근 속도
		- ![[Pasted image 20240220162602.png]]
	- 상위 부분
		- 전원이 꺼지면 내용이 사라지는 휘발성 저장 장치로 구성
		- 월등히 빠른 속도
		- 상대적으로 작은 용량
		- 당장 필요한 정보만 선ㄴ별적으로 저장하면 하위의 대용량 저장 장치와 비슷한 성능
	- 휘발성 저장 장치
		- 레지스터(Registre)
		- 캐시 메모리(Cache Memory)
		- 메인 메모리(Main Memory)
	- 캐싱 기법
		상대적으로 용량이 적은 빠른 저장 장치를 이용해 느린 저장 장치의 성능 향상시키는 기법
		- 느린 저장 장치에 있는 애용 중 당장 사용되거나 빈번히 사용될 정보를 빠른 저장 장치에 선별적으로 저장
			- 컴퓨터 데이터나 프로그램을 구성하는 부분 중 일부만 집중적으로 사용
		- 예시
			- 많은 횟수를 반복하는 코드
			- 한 번 수행되고 끝나는 코드
			- 반복 코드를 빠른 저장 장치에 올리면 적은 저장 공간만으로 전체 시스템 평균 성능 향상
	- 아랫 부분
		- 전원이 꺼져도 지워지지 않는 비휘발성 저장 장치
9. 하드웨어 의 보안
	- 다중 프로그래밍(Multi-Programming)
		여러 프로그램이 동시에 실행되는 환경
		- 각 프로그램이 다른 프로그램의 실행을 방해하거나 프로그램 간에 충돌을 일으키는 문제를 막기 위해 하드웨어에 대한 각종 보안 기법 필요
	- 커널 모드(Kernel Mode, System Mode)
		중요한 정보에 접근해 위험한 상황을 초래할 수 있는 연산은 커널 모드에서만 실행되도록 해서 보안성을 확보
		- 다른 프로그램의 메모리 영역이나 파일 영역 침범 방지
		- 운영체제가 CPU의 제어권을 가지고 운영체제 코드 실행
			- 모든 종류의 명령 실행 가능
	- 특권 명령
		시스템의 보안과 관련된 명령들
	- 사용자 모드(User Mode)
		일반 사용자 프로그램이 실행되며 제한적인 명령만 실행 가능한 모드
		- 일반 사용자 프로그램은 직접 위험한 명령 수행 불가
		- 하지만 사용자 프로그램이 CPU를 가지고 있는 동안 중요한 연산을 수행해버리면 제어가 소용 없음
			- 운영체제가 감시하지 않음
			- 하드웨어적인 지원 필요
			- CPU 내부에 모드 비트를 두어 사용자 프로그램 감시
	- 모드 비트(Mode Bit)
		특권 명령은 모드 비트가 0일 때만 즉, 커널 모드에서 운영체제에 의해서만 수행 가능
		- 모드 비트가 0이면 커널 모드로서 모든 명령 수행 가능
		- 모드 비트가 1이면 사용자 모드로서 제한뒨 명령만 수행 가능
		- 운영체제가 사용자 프로그램에게 CPU 제어권을 넘길 때 모드 비트를 1로 세팅
			- 하드웨어 접근 등 보안이 필요한 중요한 명령을 수행해야 할 경우 시스템 콜을 통해 운영체제가 대신 수행
			- 인터럽트가 발생할 때 모드 비트는 자동으로 0이 세팅
			- 운영체제가 수행을 끝내고 다시 제어권을 넘겨줄 때 모드 비트를 1로 세팅
	- 요약
		![[Pasted image 20240220164058.png]]
		- 모든 입출력 명령은 특권 명령으로 규정
			- 사용자 프로그램은 디스크에 저장된 파일에 자유롭게 접근 불가
		- 입출력이 필요한 때에는 운영체제에 시스템 콜로 대신 수행 요청
		- 입출력은 특권 명령이라 모드 비트가 0일 때에만 수행 가능
10. 메모리 보안
	여러 프로그램이 메모리에 동시에 올라가서 실행되기 때문에 다른 프로그램이나 운영체제가 위치한 메모리 영역 침범 가능, 인터럽트 벡터와 인터럽트 처리 루틴이 있는 곳은 각별한 보안 필요 
	- 기준 / 한계 레지스터
		![[Pasted image 20240220164439.png]]
		- 기준 / 한계 레지스터
		- 기준 레지스터
			- 메모리 위 프로그램의 시작 주소
			- 어떤 프로그램이 수행되는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리 상의 가장 작은 주소 보관
		- 한계 레지스터
			- 메모리 위 프로그램의 길이
			- 그 프로그램이 기준 레지스터 값부터 접근할 수 있는 메모리의 범위를 보관
	- 메모리 보호
		![[Pasted image 20240220165151.png]]
		- 메모리 접근 연산이 있을 때마다 하드웨어 적으로 현재 접근하려는 위치가 합법적인 범위에 있는지 체크
		- 사용자 프로그램은 기준 레지스터의 주소부터 기준 레지스터 + 한계 레지스터 값 사이의 주소 영역에만 접근 가능
			- 이 범위 밖의 주소에 접근시 예외 상황이라는 소프트웨어적 인터럽트 발생
			-  CPU 제어권을 운영체제로 이양시키고 해당 프로그램 강제 종료
	- 페이징(Paging)
		- 위는 하나의 프로그램이 메모리의 한 영역에 연속적으로 위치하는 단순화된 메모리 관리 기법을 사용하는 경우에 관한 설명
		- 보통은 하나의 프로그램이 메모리의 영역에 나뉘어 위치하는 페이징 기법을 사용
	- 특권 명령
		- 메모리 접근 연산은 특권 명령이 아니다.
			- 하지만 기준 레지스터와 한계 레지스터의 값을 세팅하는 연산은 특권 명령으로 규정해야 한다.
		- 프로그램이 메모리에 접근하기 전에 하드웨어적으로 그 접근이 합법적인지를 체크해 메모리 보호
		- 커널 모드에서는 메모리에 무제한으로 접근 가능
11. CPU 보호
	특정 프로그램이 무한 반복문을 수행하는 등 CPU의 사용 권한을 독점하고 있다면 가로책 방법이 없다.
	이를 해결하기 위해 운영체제는 타이머(Timer)라는 하드웨어를 사용
	- 타이머(Timer)
		- 타이머는 정해진 시간이 지나면 인터럽트를 발생시켜 운영체제가 CPU의 제어권을 획득할 수 있게 한다.
		- 타이머에 의해 발생되는 인터럽트 처리 루틴의 역할은 CPU 제어권을 빼앗아 다른 프로그램에게 이양하는 것
	- 세팅
		- 타이머는 일정한 시간 단위로 세팅 가능
			- 세팅하는 명령을 로드 타이머(Load Timer)라고 하며 이는 특권 명령이다.
		- 매 클럭 틱(Clock Tick)마다 1씩 감소
		- 0이 되는 순간 인터럽트 발생
		- 시분할 시스템에서 현재 시간을 계산하기 위해서도 사용된다.
12. 시스템 콜을 이용한 입출력 수행
	- 입출력 명령은 특권 명령
		- 사용자 프로그램이 디스크의 파일에 데이터를 쓰는 행위
		- 디스크의 파일로부터 데이터를 읽어오는 행위
		- 키보드로부터 입력을 받는 행위
		- 수행 결과를 화면에 출력하는 행위
	- 시스템 콜
		- 입출력 명령은 운영체제 코드에 구현되어 있음
		- 사용자 프로그램은 운영체제에 시스템 콜이라는 서비스 대행 요청으로 입출력 수행
		- 소프트웨어적인 인터럽트
	- 과정
		1. 사용자 프로그램이 시스템 콜
		2. 트랩이 발생
		3. CPU의 제어권이 운영체제로 넘어감
		4. 운영체제는 시스템 콜을 처리하기 위한 루틴으로 가서 정의된 명령 수행(컨트롤러에게 입출력 명령하도록 명령)
		5. 컨트롤러가 입출력 수행을 마치면 CPU에게 인터럽트 발생
		6. 사용자 프로그램이 다시 CPU를 할당받을 수 있도록 함