1. 피터슨의 해결안(Peterson's Solution)
	- 피터슨의 해결안은 임계 구역(Critical Section)문제를 소프트웨어적으로 해결하기 위한 알고리즘이다.
	- 현대 컴퓨터 구조가 load, store와 같은 기본적인 기계어를 수행하는 방식이기 때문에 피터슨의 해결안(소프트웨어적인 방법)은 임계 구역 문제 해결을 보장할 수 없다.
	- 임계 구역 문제를 해결하기 위한 알고리즘적인 설명을 제공하고 상호 배제, 진행, 한정된 대기의 요구 조건을 중점으로 수행하는 소프트웨어를 설계하는데 필요한 복잡성을 잘 설명하기 때문에 피터슨의 해결안이 제시된다.
	피터슨의 해결안은 임계 구역(Critical Section)과 나머지 구역(Remainder Section)을 번갈아 가며 실행하는 두 개의 프로세스로 한정된다.
	피터슨의 해결안은 두 프로세스가 공유하는 두 개의 데이터를 필요로 한다.
	`bool flag[2];`
	`int turn`
	- bool flag\[2] : 각각의 프로세스가 임계 구역을 사용하고자 하는 표시이다. 예를 들어 flag\[0] == true이면 0번째 프로세스가 임계 구역의 자룔르 사용하고 싶다는 의미이다.
	- int turn : turn의 값은 프로세스의 차례를 의미한다. 예를 들어 turn = 0이라면 0번째 프로세스의 차례를 의미한다.
	피터슨의 해결안에서 프로세스 i의 구조는 다음과 같다.
	![[Pasted image 20240319115943.png]]
	위와 대칭되게 프로세스 j의 구조는 다음과 같을 것이다.
	![[Pasted image 20240319121300.png]]
	피터슨의 해결안을 사용하여도 결과값은 약간씩 다른 값이 나올 수 있다. 이는 피터슨의 해결안이 소프트웨어적으로 완벽한 동기화를 보장할 수 없다는 것을 알 수 있다.
	- 피터슨의 해결안 완벽한 동기화를 제공하지 못하는데 제시되는 이유
		- 임계 구역 문제를 해결하는 것의 좋은 알고리즘적인 설명을 제공
		- 상호 배제, 진행, 한정된 대기의 요구 사항과 관련된 복합적인 개념을 설명할 수 있다.
		- 개념적으로는 완벽히 상호 배제, 진행, 한정된 대기를 해결하기 때문이다.
2. 피터슨의 해결안 증명
	- 피터슨의 해결안이 올바르게 동작하는 것을 증명하기 위한 과정
		1. 상호 배제가 제대로 지켜진다는 사실
		2. 진행에 대한 요구 조건을 만족한다는 사실
		3. 대기 시간이 한 없이 길어지지 않는다는 사실
	- 상호 배제(Mutual Exclusion) 조건이란
		2개 이상의 프로세스가 동시에 공유 자원에 접근하는 것을 예방하는 것을 의미. 즉, 2개 이상의 프로세스가 임계 구역에서 수행되면 안 된다는 조건을 의미
	- 진행(Progress, No DeadLock) 조건이란
		임계 구역을 이용하는 프로세스가 없고 한 프로세스가 임계 구역에 들어가고자 할 때 들어가게 해주어야 하는 조건이다. 만일 진행이 되지 않으면 프로세스들끼리 다른 프로세스의 해제를 기다리기 위해 계속 대기하게 된다. 이러한 현상을 교착 상태(DeadLock)이라고 하며 진행 조건이 만족한다는 의미는 교착 상태가 없어야 한다는 의미이다.
	- 한정된 대기(Bounded-Waiting, No Starvation) 조건이란
		한 프로세스가 대기중일 때 우선순위가 높은 다른 프로세스에 의해 선점이 되어 계속 무한 대기를 해서는 안된다. 이렇게 다른 프로세스에게 선점되어 무한 대기하는 현상을 기아(Starvation) 현상이라 한다. 즉, 한정된 대기 조건을 만족하기 위해서는 기아 상태가 발생해서는 안된다.
	두 프로세스의 상호 배제는 turn 변수에 의해서 지켜진다. 예를 들어 프로세스 i가 임계 구역에 드렁가기 위해서는 flag\[j] == false이거나 turn == i 이어야 한다. 하지만 turn 변수의 값은 0 또는 1이기 때문에 두 프로세스 중 하나는 while 문을 통과하지 못하여 상호 배제가 지켜진다.
	두 프로세스의 진행이 만족한다는 요구 조건은 두 프로세스의 교착 상태(DeadLock)이 없는 상태여야 한다. 이 역시 while문의 turn 변수에 의해 교착 상태가 없어진다. 이유는 사용하고자 하는 프로세스의 turn은 다른 프로세스에 의해서 결정되기 때문이다. 예를 들어 두 프로세스가 while문 이전에 도달했다면 두 프로세스 중 어느 하나는 turn을 늦게 저장할 것이다. 그렇다면 늦게 저장된 값의 프로세스가 while문을 벗어나 임계 구역에서 수행될 것이다.
	두 프로세스의 대기 시간이 한 없이 길어지지 않는다는 사실은 어느 한 프로세스의 기아(starvation)이 없는 상태여야 한다. 이 요구 조건 역시 turn 변수가 다른 프로세스에 의해 지정되기 때문에 기아 상태가 발생되지 않아 프로세스도 최소한 한 번은 임계 구역에 들어갈 수 있게 보장된다.