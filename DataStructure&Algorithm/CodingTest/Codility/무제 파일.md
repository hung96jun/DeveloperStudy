- 문제
```
한 명의 플레이어를 위한 게임은 0부터 N − 1까지 번호가 매겨진 N개의 연속 사각형으로 구성된 보드에서 진행됩니다. 각 사각형에는 숫자가 적혀 있습니다. N개의 정수로 구성된 비어 있지 않은 배열 A에는 사각형에 적힌 숫자가 포함됩니다. 또한 일부 사각형은 게임 중에 표시될 수 있습니다.
- 중요한것은 N개의 연속 사각형으로 구성된 보드에서 진행.
- 0부터 N-1까지의 번호는 인덱스를 의미하는 것 같다.

게임이 시작될 때 사각형 번호 0에 조약돌이 있고 이것이 표시된 유일한 사각형입니다. 게임의 목표는 조약돌을 정사각형 번호 N - 1로 옮기는 것입니다.
- 0번 인덱스부터 N-1(마지막)인덱스까지로 이동시키는 것이 목표

매 턴마다 우리는 앞면에 1부터 6까지의 숫자가 적힌 6면체 주사위를 던지고, 주사위가 정지된 후 윗면에 표시되는 숫자 K를 고려합니다. 그런 다음 제곱수 I + K가 존재한다면 제곱수 I에 서 있는 조약돌을 제곱수 I + K로 옮깁니다. 제곱수 I + K가 존재하지 않으면 유효한 수를 얻을 때까지 주사위를 다시 던집니다. 마지막으로 사각형 숫자 I + K를 표시합니다.

게임이 끝난 후(조약돌이 N-1의 사각형 위에 서 있을 때) 결과를 계산합니다. 게임의 결과는 표시된 모든 사각형에 적힌 숫자의 합입니다.

예를 들어 다음과 같은 배열이 있다고 가정합니다.

A[0] = 1 
A[1] = -2 
A[2] = 0 
A[3] = 9 
A[4] = -1 
A[5] = -2

===============================================================

가능한 게임 중 하나는 다음과 같습니다.

> - 조약돌은 표시된 사각형 번호 0에 있습니다.
> - 우리는 3개를 던졌습니다. 조약돌은 0번 사각형에서 3번 사각형으로 이동합니다. 우리는 사각형 번호 3을 표시합니다.
> - 우리는 5를 던졌습니다. 보드에 사각형 숫자 8이 없기 때문에 조약돌은 움직이지 않습니다.
> - 우리는 2를 던졌습니다. 조약돌은 5번 사각형으로 이동합니다. 이 사각형을 표시하면 게임이 종료됩니다.

표시된 사각형은 0, 3, 5이므로 게임 결과는 1 + 9 + (−2) = 8입니다. 이는 이 보드에서 얻을 수 있는 최대 결과입니다.

이는 N개의 정수로 구성된 비어 있지 않은 배열 A가 주어지면 배열 A로 표시되는 보드에서 달성할 수 있는 최대 결과를 반환합니다.

===============================================================

예를 들어, 배열이 주어지면

A[0] = 1 
A[1] = -2 
A[2] = 0 
A[3] = 9 
A[4] = -1 
A[5] = -2

위에서 설명한 대로 함수는 8을 반환해야 합니다.

다음 가정에 대한 ****효율적인**** 알고리즘을 작성하십시오 .

> - N은 [ 2 .. 100,000 ] 범위 내의 정수입니다 .
> - 배열 A의 각 요소는 [ −10,000 .. 10,000 ] 범위 내의 정수입니다 .

```

- 다른 사람 풀이
```C++
int solution(vector<int>& A) 
{
    // dp에는 지나온 위치의 값들을 누적하여 저장
    vector<int> dp(A.size());
    dp[0] = A[0]; // 시작할 때  0부터 시작이므로 0을 입력
    
    for (int i = 1; i < A.size(); i++) // A 루트만큼 반복
    {
        int pre = dp[i - 1] + A[i]; // 이전의 값 + 현재의 값
        for (int j = 2; j <= 6; j++) // 다이스를 굴렸을 때
        {
// i == 1, j == 2일때 -1인덱스 값이 되기 때문에 예외처리
            if (i - j < 0) 
                continue;
// (이전의 값 + 현재의 값) or (현재의 값 + 다이스 위치의 값)
            pre = max(pre, dp[i - j] + A[i]); 
        }

        dp[i] = pre; // 누적 값 저장
    }

    return dp[A.size() - 1]; // 마지막 값 저장
}
```