프로그램을 설계할 때 발생했던 문제점들을 <font color="red">객체 간의 상호 관계등을 이용하여 해결할 수 있도록 하나의 '규약' 형태</font>로 만들어 놓은 것.

- 싱글톤
	하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴. 하나의 클래스를 기반으로 여러 개의 개별적인 인스턴스를 만들 수 있지만, ==단 하나의 인스턴스를 만들어 이를 기반으로 로직을 만드는데 사용==되며, 보통 데이터베이스 연결 모듈에 많이 사용됨.
	하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 <font color="yellow">인스턴스를 생성할 때 드는 비용이 줄어드는 장점</font>이 있지만, <font color="red">의존성이 높아진다는 단점</font>이 있다.
	- 특징
		- 단점
		  TDD(Test Driven Development)를 할 때 걸림돌이 된다. TDD를 할 때 단위 테스트를 주로 하는데, 테스트가 서로 독립적이어야 하며 테스트는 어떤 순서로든 실행할 수 있어야 한다.
		  하지만 실글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴으로 각 테스트마다 '독립적인' 인스턴스를 만들기가 어렵다.
		- 의존성 주입
		  싱글톤 패턴은 사용하기 쉽고 굉장히 실용적이지만 ==모듈 간의 결함을 강하게 만들 수 있다.== 이때 <font color="red">의존성 주입(DI, Dependency Injection)을 통해 모듈 간의 결함을 조금 더 느슨하게 만들어 해결</font> 할 수 있다.
		  이 때문에 <font color="red">메인 모듈(상위 모듈)은 하뒤 모듈에 대한 의존성이 떨어지며, 디커플링</font>이 된다.
		- 의존성 주입 장단점
		  모듈들을 쉽게 교체할 수 있는 구조가 되어 ==테스팅 하기 쉽고 마이그레이션 하기 수월하다.== 또한, 구현할 때 추상화 레이어를 넣고 이를 기반으로 <font color="red">구현체를 넣어 주기 때문에 애플리케이션 의존성 방향이 일관되고, 애플리케이션을 쉽게 추론할 수 있으며, 모듈 간의 관계들이 조금 더 명확해 진다.</font>
		  하지만 모듈들이 더욱 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있으며 약간의 런타임 패널티가 발생하기도 한다.
		- ==의존성 주입 원칙==
		  상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 하며, 둘 다 추상화에 의존해야 하고, 이때 추상화는 세부 사항에 의존하지 말아야 한다.

- 팩토리 패턴
	객체를 사용하는 코드에서 <font color="red">객체 생성 부분을 떼어내 추상화한 패턴</font>이자 ==상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴.==
	상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지며 상위클래스에서는 <font color="yellow">인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 더 많은 유연성을 갖게된다.</font> 그리고 객체 생성 로직이 따로 떼어져 있기 때문에 코드 리팩터링하더라도 한 곳만 고칠 수 있게 되니 유지 보수성이 증가된다.

- 전략 패턴
	전략 패턴(Strategy Pattern)은 정책 패턴(Policy Pattern)이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴.

>[!Tip] 컨텍스트
>프로그래밍에서의 컨텍스트는 상황, 맥락, 문맥을 의미하며 개발자가 어떠한 작업을 완료하는데 필요한 모든 관련 정보를 의미함.

- 옵저버 패턴
	옵저버 패턴(Observer Pattern)은 주제가 어떤 객체(Subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 주체에게, 주체는 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴
	여기서 주체란 객체의 상태 변화를 보고 있는 관찰자이며, 옵저버들이란 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 '추가 변화 사항'이 생기는 객체들을 의미.
	또한 주체와 객체를 따로 두지 않고 상태가 변경되는 객체를 기반으로 구축되기도 함. 옵저버 패턴을 활용한 서비스로는 트위터가 있다.
	옵저버 패턴은 주로 이벤트 기반 시스템에 사용하며 MVC(Model-View-Controller) 패턴에도 사용된다.
	예를 들어 주체라고 볼 수 있는 모델(Model)에서 변경 사항이 생겨 Update() 메서드로 옵저버인 뷰에게 알려주고 이를 기반으로 컨트롤러(Controller)등이 작동하는 것이다.

>[!tip] 프록시 객체
>프록시(Proxy) 객체는 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체를 의미한다.
>해당 객체는 디자인 패턴 중 하나인 프록시 패턴이 녹아들어 있는 객체이다.

- 프록시 패턴
	프록시 패턴(Proxy Pattern)은 대상 객체(Subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 해당 접근을 필터링하거나 수정하는 등의 역할을 하는 계층이 있는 디자인 패턴이다. 이를 통해 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용된다. 이는 프록시 객체로 사용되기도 하지만 프록시 서버로도 활용된다.
	- 프로시 서버
		프록시 서버(Proxy Server)는 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다.![[Pasted image 20231126182629.png]]
>[!tip] 용어
>- 버퍼 오버플로우
>	버퍼는 보통 데이터가 저장되는 메모리 공간으로, 메모리 공간을 벗어나는 경우를 의미한다. 이때 사용되지 않아야 할 영역에 데이터가 덮어씌어져 주소, 값을 바꾸는 공격이 발생하기도 한다.
>- gzip 압축
>	LZ77과 Huffman 코딩의 조합인 DEDFAULT 알고리즘을 기반으로 한 압축 기술. gzip 압축을 하면 데이터 전송량을 줄일 수 있지만, 압축을 해제했을 때 서버에서의 CPU 오버헤드도 생각해서 gzip 압축 사용 유무를 결정해야 함.

>[!tip] CDN(Content Delivery Network)
>각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크를 의미. 이를 통해 사용자가 웹 서버로부터 콘텐츠를 다운로드하는 시간을 줄일 수 있다.

- 이터레이터 패턴
	이터레이터 패너(Iterator Pattern)은 이터레이터(Iterator)를 사용하여 컬렉션(Collection)의 요소들에 접근하는 디자인 패턴. 이것을 통해 순회할 수 있는 여러 가지 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 순회가 가능.

>[!tip] 이터레이터 프로토콜
>이터러블한 객체들을 순회할 때 사용되는 규칙

>[!tip] 이터러블한 객체
>반복 가능한 객체로 배열을 일반화한 객체

- 노출모듈 패턴
	노출모듈 패턴(Revealing Module Pattern)은 즉시 실행 함수를 통해 Private, Public 같은 접근 제어자를 만드는 패턴을 의미. (java에서만 사용하는 패턴인가?)

- MVC 패턴
	MVC 패턴은 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴.![[Pasted image 20231126184822.png]]
	애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있다. 재사용성과 확장성이 용이하다는 장점이 있과, 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는 단점이 있다.
	- 모델
		모델은 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 의미.
	- 뷰
		뷰는 InputBox, CheckBox, TextArea등 사용자 인터페이스 요소를 나타낸다. 즉, 모델을 기반으로 사용자가 볼 수 있는 화면을 의미. 모델이 가지고 있는 정보를 따로 저장하지 않아야 하며 단순히 사각형 모양 등 화면에 표시하는 정보만 가지고 있어야 한다.
		또한, 변경이 일어날경우 컨트롤러에 이를 전달해야 한다.
	- 컨트롤러
		컨트롤러는 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당. 또한, 모델과 뷰의 생명주기도 관리하며, 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용에 대해 알려준다.
- MVP 패턴
	MVP패턴은 MVC 패턴으로부터 파생되었으며 MVC에서 C에 해당하는 컨트롤러가 프레젠터(Presenter)로 교체된 패턴이다.![[Pasted image 20231126184613.png]]
	뷰와 프레젠터는 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지닌 디자인 패턴이라고 볼 수 있다.
- MVVM 패턴
	MVVM 패턴은 MVC의 C에 해당하는 컨트롤러가 뷰모델(New Model)로 바뀐 패턴이다.![[Pasted image 20231126192113.png]]
	여기서 뷰 모델은 뷰를 더 추상화한 계층이며, MVVN 패턴은 MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징이다. 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다는 장점이 있다.
>[!tip] 커맨드
>여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법
>

>[!tip] 데이터 바인딩
>화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로, 뷰모델을 변경하면 뷰가 변경된다.
