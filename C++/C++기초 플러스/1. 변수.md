C++의 여러 정수형들은 서로 다른 크기의 메모리를 사용하여 값을 저장한다.
signed자료형은 양수 값과 음수 값을 모두 나타낼 수 있으나, unsigned 자료형은 양수 값만 나타낼 수 있다. C++의 기본 정수형을 크기 순서로 나열하면 char < short < int < long < long long 순서이다. 이 기본형들에 대해 signed형과 unsigned 형이 각각 따로 존재한다.(char형은 수 대신 문자를 나타낼 수 있는 특별한 속성을 가지고 있다.)

- short, int, long long 정수형
	컴퓨터의 메모리는 비트(bit)라는 단위로 이루어진다. 이러한 자료형들의 메모리는 최소 크기만들 정하여 융통성 있는 표준을 제공한다.

- unsigned 형
	위의 정수형들은 음의 정수 값을 저장할 수 없는 unsigned 변형을 가지고 있다. unsigned 형을 사용하면 음의 정수 값을 저장할 수 없는 대신 양의 정수의 최대 값을 약 두 배 만큼 더 저장할 수 있다. 하지만 이러한 경우에도 최소 값 혹은 최대 값을 넘어가게 되면 그 반대의 한계 값으로 넘어가게 된다.

- 정수형의 사용
	일반적으로 int형은 컴퓨터가 가장 효율적으로 처리할 수 있는 정수형이다. 그렇기에 특별한 경우를 제외하고는 int형을 사용하는 것이 좋다.
	- unsigned : 값이 절대 음수가 될 수 없는 수를 나타낼 때에 사용
	- long : 16비트로 나타낼 수 잇는 정수보다 더 큰 정수 값을 나타낼 때에 사용(int형이 32비트일 때에도 동일하다.)
	- short : int형보다 크기가 작을 경우 short형을 사용하는 것이 메모리를 절약할 수 있다.(커다란 정수 배열을 사용할 때에 특히 유용하다.)
	- char : 1Byte의 메모리만 필요할 때에 사용한다.
- char형 : 문자와 작은 정수
	프로그래밍 언어들은 문자를 수치 코드(ASCII코드)로 나타낸다. 이때에 사용되는 자료형이 char형으로 문자와 숫자를 저장할 때에 사용되는 자료형이다. 대부분의 컴퓨터 시스템들은 256개보다 적은 개수의 문자를 지원하기 때문에 1Byte의 메모리만으로 충분히 표현할 수 있다. 그렇기에 char형은 메모리적으로 문자를 저장하고 처리하는데에 적합하고, short형보다 작은 범위의 정수를 나타내는 데에도 사용할 수 있다.
	일반적으로 사용되는 문자 세트는 ASCII코드가 있으며, IBM 메인 프레임에서는 EBCDIC문자 세트를 사요한다. 하지만 이러한 문자 세트들은 국제적인 요구를 모두 수용할 수 없기 때문에 C++은 Unicode 국제 문자 세트를 사용할 수 있는 확장 문자형을 지원한다.
	변수를 입출력 할 때에 ASCII나 EBCDIC같은 문자 세트의 숫자 코드값을 입력하는 것이 아닌 문자를 입력하여 변수에 값을 저장한다. 문자와 관련된 처리는 char 자료형이 하는 것이 아니라, cin과 cout 함수가 이러한 변환 작업을 수행하게 된다. cin은 입력된 문자 값을 숫자 코드로 변환하는 작업을 한다. 반면, cout은 저장된 숫자 코드값을 문자로 변환하는 작업을 한다.
	C++에서 문자 상수를 나타낼 때에 작은 따옴표를 사용하여 감싸며, 문자열을 나타낼 때에는 큰 따옴표를 사용한다. <font color="red">문자 상수와 문자열은 완전히 별개의 것이다.</font>
	- 멤버 함수 cout.put()
		클래스는 데이터 형식과 그 데이터를 다루는 방법을 정의해 놓은 것이다. 이렇게 함수에 마침표`.`를 붙인 한수는 멤버 함수라 칭하며, 멤버 함수는 클래스에 속하고, 클래스 데이터를 다루는 방법을 정의한 함수이다.
	- 이스케이프 시퀀스
		이스케이프 시퀀스란 \\n, \\"와 같이 문자열에 사용되는 특수 문자이다. 이스케이프 시퀀스를 사용하여 한 문자열 안에 다음 줄로 넘어가는 개행 작업이나, 따옴표를 입력하는 작업을 할 수 있게 해주는 문자이다.
- 확장 char : wchar_t
	char형은 기본적으로 1Byte(8Bit)로 표현이된다. 하지만 1Byte로 표현할 수 없는 문자 세트들이 있다.(ex : 중국어, 한국어, 일본어 등의 문자 세트) 이러한 문자 세트를 사용하는 방법으로는 두 가지가 있다.
	1. 컴파일러 개발자가 처음부터 char형을 2Byte 혹은 그 이상으로 제작
	2. 기본 문자 세트와 확장 문자 세트를 동시에 지원
	이럴 경우 보통 1Byte 문자 세트를 사용할 때에는 char형, 그 이상의 바이트 문자 세트를 사용할 때를 wchar_t(wide character type)을 사용하는 것이다.
	<font color="red">단점 : 특별한 경우에 문자열을 변환하게 되면 부호가 고정될 필요가 있다. wchar_t의 부호와 길이는 가변이기 때문에 문제가 발생할 수 있다.</font>
- char16_t과 char32_t
	wchar_t의 단점으로 인해 unsigned 16bit 형인 char16_t과 unsigned 32Bit 형인 char32_t이 개발되었다. char16_t은 대입받는 값의 접두사로 u를 사용하고, char32_t은 대입받는 값의 접두사로 U를 사용한다. wchar_t, char16_t, char32_t과 같이 \_를 가지고 있는 자료형들은 정수형의 일종이지만, 시스템마다 다를 수 있다.
- 부동 소수점수
	부동 소수점형은 0.1과 같이 소수부가 있는 수를 나타낼 수 있다. 또한 매우 큰 값들을 나타낼 수 있다. 예를 들어 값이 너무 커서 long형으로 나타낼 수 없는 경우 부동 소수점형으로 나타낼 수 있다. <font color="red">컴퓨터는 소수부가 있는 이러한 값을 두 부분으로 나누어 저장한다. 한 부분은 기본값을 나타내고, 다른 한 부분은 기본값을 키우거나 줄이는 스케일을 나타낸다.</font> 두 수 34.1234와 34123.4가 있을 때, 이 두 수는 기본값은 같고 스케일만 다르다. 첫 번째 수는 기본값이 0.341234, 스케일이 100이고, 두 번째 수는 기본값이 0.341234, 스케일이 100000이다. <font color="red">소수점이 스케일을 따라 자리를 옮기기 때문에 이 데이터형을 부동 소수점형 이라고 부른다.</font>
	C++이 부동 소수점수를 나타내는 두 번째 방법은 3.4E6과 같은 지수 표기(Enotation)을 사용하는 것이다. 3.45E6은 값 3.45에 1,000,000을 곱한다는 의미이다. E6은 10의 6제곱을 의미하므로 3.45E6은 3,450,000이 된다. 이러한 방법을 사용하여 <font color="red">부동 소수점수의</font> <font color="green">지수표기</font><font color="red">는 매우 큰 수나 매우 작은 수를 나타내는 데 무척 유용하다.</font>
	이러한 지수 표기 방법을 사용하여 부동 소수점수로 매우 작은 수도 나타낼 수 있다. 3.45E-6이라는 값으로 <font color="red">지수 앞에 -부호를 사용할 경우 10의 거듭 제곱수로 나누게 된다.</font> 그래서 0.00000345이라는 값으로 나타낼 수 있다.
	- 정밀도
		float 형에 10.0 / 3.0의 값으로 초기화하고 백만을 곱한 후 출력해보면 3333333.333333이 아닌 3333333.250000와 같이 정확한 값이 출력되지 않는 것으로 확인할 수 있다. (cout은 소수점 아래 6자리까지 출력할 수 있다.)하지만 double형으로 나타낼 경우 3333333.333333값이 출력되는데, 이 이유는 시스템 상으로 float형은 6개의 유효 숫자를 보장(최악의 경우를 고려했을 때)하고, double형 변수는 15개의 유효 숫자를 보장한다.
		- 부동 소수점형 상수
			부동 소수점형 상수는 기본적으로 double형으로 저장이 된다. 부동 소수점형 상수를 float형으로 저장하고 싶으면 f나 F를 접미어로, long double형으로 저장하고 싶으면 l이나 L을 접미어로 사용해야 한다.
		- 부동 소수점의 장점
			부동 소수점수는 정수에 비해 두 가지의 장점을 가진다.
			- 수와 정수 사이에 있는 값을 나타낼 수 있다.
			- 스케일을 사용하여 매우 큰 범위의 값을 나타낼 수 있다.
		- 부동 소수점의 단점
			- 부동 소수점수 연산은 수치 연산 보조 프로세서(math comperocessor)가 없는 컴퓨터에서 정수 연산보다 속도가 느리고, 정밀도가 떨어질 수 있다.

- 연산자 우선순위와 결합 방향
	복잡한 산술 연산을 사용할 때에는 C++이 사용하는 연산 규칙을 알아야 한다. 하나의 수식에 여러개의 연산자 중에서 어느 연산자를 먼저 적용할 것인지를 결정하는 우선순위(Precedence) 규칙이라는 것이 존재한다. 산술 연산자는 일반 대수학의 우선순위 규칙을 따른다.

- 나눗셈 연산자
	나눗셈 연산자(/)를 사용하는 연산은 피연산자의 데이터형에 따라 결과가 달라진다. 두 피연산자가 모두 정수이면 정수 나눗셈을(즉, 결과의 소수부를 버리고 정수로 만든다.), 피연산자 하나가 부동 소수점수이거나, 두 피연산자가 모두 부동 소수점수이면 결과는 부동 소수점수가 된다.(부동 소수점형 상수는 기본적으로 double형이다.)
	
>[!tip] Bit와 Byte
>컴퓨터의 메모리를 구성하는 기본 단위는 비트(Bit)이다. 비트의 개념은 0과 1로 이루어진 2진수이다. 8비트의 폭은 256가지의 비트 조합을 만들 수 있다.(2의 8승) 따라서 8비트는 0부터 256까지 또는 -128 ~ 127까지의 값을 나타낼 수 있다. 비트 하나가 추가될 때마다 비트 조합의 수는 제곱배가 된다. 일반적으로 바이트(Byte)는 8비트의 메모리 단위를 의미한다. 바이트 단위로 컴퓨터의 메모리 크기를 나타낼 때, 1KByte는 1024Byte, 1MByte는 1024KByte 이다.
>
><font color="red">예외사항</font>
>C++은 바이트를 조금 다르게 정의한다. C++에서 바이트는 컴파일러의 기본 문자 세트를 수용할 수 있는 최소한의 연속된 비트들로 구성된다.
>즉, 바이트를 구성하는 비트들의 조합으로 나타낼 수 있는 길이의 수가 컴파일러가 사용할 수 있는 문자 수와 같거나 그보다 커야 한다.
>기본적으로 사용하는 문자 세트는 대게 ASCII와 EBCDIC이다. 이 문자 세트를  사용하는 시스템에서 C++의 바이트는 8비트이다. 그러나 국제적으로 사용되는 프로그램을 개발하려면 Unicode와 같이 더 큰 문자 세트가 필요하다. 이와 같이 더 큰 문자 세트를 사용하는 시스템에서는 C++의 바이트가 16비트 또는 32비트여야 한다. 종종 8자리 수를 나타내기 위해 "octer"용어를 사용하기도 한다.

- 기호 상수와 전처리기
	C++의 컴파일 과정은 먼저 소스를 전처리기로 보낸다. 여기서 #define 은 #include 와 같은 전처리기 지시자이다. #define 지시자는 소스 코드를 검색하여 define된 상수 명을 상수 값으로 대체된 소스 코드가 컴파일 과정으로 넘겨진다. 전처리기는 독립 토큰에만(분리된 단어에만) 적용되고, <font color="yellow">파묻힌 단어들은 건너띈다. (무슨말인지 이해가 안된다.)</font>
	#define 지시자는 사용자 스스로 기호 상수를 정의할 때에도 사용할 수 있다. #define 지시자는 C에서 많이 사용하던 방식으로 C++에서는 #define이 아닌 const 키워드로 대체해서 사용한다.
- const 제한자
	cont 제한자란 상수를 정의하는 방법으로 #define 문보다 더 간편히 상수를 다루는 방법이다. `const` 제한자를 사용할 때에는 `const` 상수를 선언하면서 초기화도 같이 해줘야 한다. 그러면 컴파일러는 해당 상수의 값을 변경하는 어떠한 시도도 허용하지 않게 된다. 이러한 키워드 `const`는 선언의 의미를 제한하므로 제한자(Qualifier)라고 부른다.
	#define 을 사용하는 것보다 `const`를 사용하는 것이 더 좋다. 그에 대한 이유는 다음과 같다.
	- 데이터형을 명시적으로 지정할 수 있다.
	- C++의 활동 범위 규칙(scoping rule)에 의해 그 정의를 특정 함수나 파일에서만 사용할 수 있도록 제한할 수 있다는 점이다.(활동 범위 규칙이란 어떤 식별자가 서로 다른 여러 모듈에 얼마나 널리 알려지는가를 나타내는 규칙이다.)
	- 배열이나 구조체같은 복잡한 데이터형에도 `const`를 사용할 수 있다는 점이다.

- 데이터형 변환
	- 자동으로 데이터형 변환
		- 특정 데이터형의 변수에 따른 데이터형의 값을 대입했을 때
		- 수식에 데이터형을 혼합하여 사용했을 때
		- 함수에 매개변수를 전달할 때
	1. 대입 구문에서의 데이터형 변환
		short형(16Bit) 값을 long형(32Bit) 변수에 대입을 할 때 대입되는 변수의 자료형(long형)의 비트 값으로 확장하여, 혹은 축소하여 대입하게 된다. 중요한 것은 확장할 때는 여분의 바이트만 추가된다. 그러나 값이 큰 자료형에서 작은 자료형으로(예를 들어 long형의 값을 float형 변수에 대입할 때) 변환하게 되면 정밀도가 손실된다.
		- 데이터형 변환의 잠재적인 문제점
			- 큰 부동 소수점형을 작은 부동 소수점형으로(double -> float) : 정밀도(유효 숫자)가 손실된다. 원래 값이 변환 데이터형의 범위를 벗어날 경우 결과를 예측할 수 없다.
		-  부동 소수점형을 정수형으로(double -> int) : 소수부를 잃는다. 원래 값이 변환 데이터형의 범위를 벗어날 경우 결과를 예측할 수 없다.
		- 정수형을 작은 정수형으로(long -> short) : 원래 값이 변환 데이터형의 범윌를 벗어날 경우, 대개 하위 바이트들만 복사된다.
	2. { }를 사용할 경우 초기화 변환
		C++11은 중괄호를 이용하여 초기화를 할 수 있다. 대입되는 변수의 자료형이 대입된 값으로 표현할 수 없을 경우에는 초기화를 허용하지 않는다. 만일, 변수가 완벽히 값을 유지할 수 있다면, 정수형을 다른 정수형이나 부동 소수점형으로 변환할 경우는 허용이 될 수 있다.
		c4는 다른 예시와는 달리 조금 특수한 경우이다. c4에 대입되는 x변수의 값은 66이지만, 컴파이러는 x가 변수이고 대입되는 변수의 자료형보다 큰 값을 가질 수 있다고 생각하게 된다. x가 초기화되고 c4가 x를 이용해 초기화되기까지 x가 어떤 값으로 변환되었는지 확인하는 것은 컴파일러의 역할이 아니기 때문이다. <font color='red'>즉, { }를 사용하여 초기화를 할 경우에는 상수의 값만 사용하여 초기화를 해야한다.</font>
		- <code>char c1 { 31325 };</code>  // 허용 범위 초과, 축소 변환 허용 안됨 
		- <code>char c2 = { 66 };</code>  // 값을 유지할 수 있음, 허용
		- <code>char c3 = { code };</code>  // 상수형 int 변수 code가 66이기 때문에, 위와 같은 이유로 허용
		- <code>char c4 = { x };</code>  // x가 상수가 아니기 때문에 허용 안됨
		- <code>x = 31325; char c5 = x;</code>  // 초기화에 의해 허용됨
	3. 수식에서의 데이터형 변환
		- 자동 데이터형 변환
			- 데이터형들이 나타날 때마다 자동으로 데이터형이 변환된다.
			- 수식에서 다른 데이터형과 혼합하여 사용되었을 때 데이터형이 변환된다.
			정수 자료형 값은 모두 int형으로 변환된다.(단, bool형일 경우 true는 1로, false는 0으로 변환된다.) 이러한 변환을 정수 승급(integral promotion)이라 한다.
			- <code>short variable1 = 20;</code>
			- <code>short variable2 = 35;</code>
			- <code>short result = variable + variable2;</code>
			세 번째 행의 연산을 수행할 때, C++ 프로그램은 variable1과 variable2의 값을 int형으로 변환 후에 더한다. 그리고 더한 결과값을 short형으로 다시 변환하여 short형 변수 result에 대입하게 된다.<font color='red'>int형으로 변환하는 이유는 일반적으로 컴퓨터가 내부에서 가장 자연스럽게(빠르게) 처리되는 데이터형이 int형이기 때문이다.</font>
			int형과 float형의 연산과 같이, <font color='red'>서로 다른 데이터형을 연산할 경우에는 작은 크기의 데이터형이 큰 크기의 데이터형으로 변환된다.</font>
		- 매개변수를 전달할 때의 형 변환
			함수에 매개변수를 전달할 때 일어나는 데이터형 변환은 함수 원형이 제어하게 된다. 매개변수에 값을 전달하게 되면 매개변수의 자료형으로 전달된 변수의 자료형이 변환되게 된다. 현명한 일은 아니지만, 함수 원형이 매개변수를 제어하는 것을 막을 수도 있다. 그러한 경우 C++은 char형과 short형에 대해 정수 승급을 수행한다.
		- 데이터형 변환자
			C++에서는 데이터형 변환자를 사용하여 강제로 데이터형을 변환시킬 수 있다. 데이터형 변환자는 두 가지 형태로 사용된다.
			- <code>(int) variable;   // variable의 int형 변환을 반환한다.</code>
			- <code>int (variable);  // variable의 int형 변환을 반환한다.</code>
			데이터형 변환자는 변수 자체를 변경하지 않는다. 그 대신 지시된 데이터형의 새로운 값을 만들게 된다.
			- static_cast< > : 명시적으로 자료형 변환 작업을 수행한다.
				1. 장점 : static_cast는 컴파일 타임에 형 변환을 해주기 때문에 컴파일 시 타입에 대한 오류를 검사할 수 있다.
				2. 단점 : 
				3. 비호환성을 방지하기 위해 컴파일 시간에 static_cast 변환을 검사한다.
				4. 업 캐스팅, 다운 캐스팅을 제외한 포인터의 형 변환은 불가능하다.(C는 가능하다.)
				5. 런타임 유형 검사는 수행되지 않는다.
			- const_cast< > : 상수로 선언한 객체의 값을 변경하거나, 상수로 선언한 객체의 특성을 제거하는 데 사용된다.
			- reinterpert_cast< > :
			- dynamic_cast< > : 
>[!tip] volatile 한정자
>컴파일러에 의해 변수가 최적화되는 상황을 방지하기 위해 사용하는 한정자이다.
><code>volatile int test1;</code>
><code>volatile int* test2;</code>

- auto 선언
	<font color='red'>C++11은 초기화하는 값을 보고 변수형을 추론할 수 있다. auto 자료형은 자동으로 데이터형을 추론하는 자료형이 아니다. auto를 사용하기 좋은 곳은 STL(Standard Template Library)을 사용할 때와 같이 복잡한 변수형을 다룰 때 매우 유용하다.</font>

- 연산자 오버로딩
	int 나눗셈, float 나눗셈, double 나눗셈은 동일한 연산자를 사용하지만, 피연산자의 데이터형을 파악하여 다른 연산을 동작하게 된다. 이렇게 동일한 연산자가 서로 다른 연산에 사용되는 것을 연산자 오버로딩(operator overloading)이라 한다. 연산자 오버로딩의 개념은 사용자가 정의하는 클래스에까지 확장할 수 있다.

- cout 출력
	C++에서는 큰 따옴표 안에 들어 있는 연속된 문자들을 문자열(string)이라 한다. << 표시는 구문이 그 문자열 cout에 전달한다는 것을 의미한다. <<(삽입 연산자)가 나타내는 방향이 정보의 흐름을 상징한다.
	출력은 프로그램으로부터 흘러나오는 일련의 문자들, 즉 스트림(stream)이다. cout 객체가 이 스트림을 나타내며, endl을 출력 스트림에 삽입하면 화면 커서가 다음 행의 시작 위치로 이동하게 된다.(개행을 의미한다.) 이러한 특별한 표기법들을 조정자(manipulator)라고 부른다.
	cout에 쌍따옴표를 안붙이고 변수만 대입할 경우 cout은 해당 변수에 저장되어 있는 값을 자료형과 상관없이 출력하게 된다.
- cout과 printf( )의 차이
	- printf( ) : %d나 %s와 같은 변환 지정자들을 반드시 사용해야 변수의 값을 출력할 수 있다.
	- cout : 여러가지 데이터형을 스스로 판단할 수 있고, 생김새가 단순하며, 사용자 정의 데이터형을 인식할 수 있도록 기능을 확장할 수 있다. cout 구문의 특징은 어떠한 자료형이어도 일련의 문자 형식으로 변환하여 출력한다는 특징이 있다. 또한 cin 구문도 cout과 마찬가지로 일련의 문자들을 그것을 저장할 변수의 자료형으로 변환하여 저장하게 된다.
- cout 연산자 오버로딩
	<<(삽입 연산자)가 왼쪽 시프트 비트 연산자와 기호가 같다. 이것은 연산자 오버로딩의 한 예이다. 연산자 오버로딩에 의해 동일한 연산자 기호가 여러가지 의미를 가질 수 있다. 컴파일러가 전후 관계를 파악하여 그 연산자가 어떤 의미로 사용되는 것인지 결정한다. 중요한 것은 연산자들이 무슨 기능을 하느냐가 중요한 것이 아니다. <font color='red'>동일한 연산자가 여러 의미로 사용될 수 있다는 사실과, 컴파일러가 전후 관계를 파악하여 연산자의 의미를 결정한다는 사실이 중요하다.</font>

- 변수의 선언
	변수를 선언한다는 것은 앞으로 그 프로그램에서 그 기억 공간에 저장되어 있는 값을 변수의 이름으로 호출하여 사용하겠다고 선언하는 것이다.(변수라는 이름은 변경될 수 있는 값이기 때문에 붙여진 이름이다.)
	변수 중에 약간 복잡한 것으로 참조(reference) 선언 구문이라는 것도 있다. 참조 선언 구문은 어딘가 다른 곳에서 이미 정의된 변수를 사용할 수 있도록 허용한다. 일반적으로 선언이 꼭 정의일 필요는 없다.

- 키워드
	키워드는 컴퓨터 프로그래밍 언어가 사용하는 단어이다. 키워드들은 C++에서 용도가 따로 정해져 있으므로 다른 용도로는 사용할 수 없다. 즉, return이나 자료형 같은 것들을 변수나 함수 등의 이름으로 사용할 수 없다.