- C++ 기초
	C++은 원래 C에 객체지향 개념을 추가하려는 목적으로 설계했기 때문에 '클래스가 추가된 C'라고도 부른다. 또한 C언어에서 불편하거나 어색한 부분도 개선됐다. C++은 C언어에 기반을 두고 있다.
	- 전처리 지시자
	- C++ 소스코드를 프로그램으로 만드는 빌드작업은 세 단계를 거침
		- 전처리  : 소스코드에 담긴 메타 정보를 처리
		- 컴파일 : 소스코드를 머신이읽을 수 있는 객체 파일로 변환
		- 링크 : 변환한 여러 객체 파일을 애플리케이션으로 엮음
	- 자주 사용하는 전처리 지시자
		![[Pasted image 20240105145730.png]]
	- 중복 인클루드를 막는 용도로 전처리 지시자를 사용하는 예시. 
		![[Pasted image 20240105151504.png]]
	- main 함수
		프로그램은 항상 main 함수에서 시작하며, main함수는 int 타입의 값을 리턴. 이 값으로 프로그램의 실행 상태를 표시할 수 있음. main 함수는 매개변수를 받지 않거나 두 개를 받도록 작성할 수 있음
	==int main(int argc, char* argv[])==
		argc는 프로그램에 전달할 인수의 개수를 지정하고, argv는 전달할 인수의 값을 담음. argv[0]에는 프로그램의 이름이 담기는데, 공백 스트링으로 지정될 수도 있어서 프로그램 이름을 참조하려면 이 값보다는 플랫폼에서 제공하는 기능을 사용하는 것이 좋음. 주의할 점은 실제 매개변수는 인덱스 1부터 시작한다는 점.
	
	- I/O Stram
		endl은 스트림에 줄바꿈 문자를 추가한 뒤 현재 버퍼에 있는 내용을 출력 장치로 내보낸다. endl은 성능에 영향을 미치기 때문에 특히 루프와 같은 문장에서 남용하면 좋지 않지만, <font color="red">\n은 스트림에 줄바꿈 문자를 추가하지만 버퍼를 자동으로 비우지 않는다.</font> C++에서는 format 함수나 스트림 라이브러리를 사용하는 것이 바람직하다. <font color="yellow">C에서 사용하는 printf()나 scanf() 함수는 타입 안정성을 보장하지 않기 때문이다.</font>

- 네임스페이스
	코드에서 이름이 서로 충돌하는 문제를 해결하기 위해 나온 개념으로, 네임스페이스 안에 함수 혹은 변수가 정의되면 네임스페이스의 스코프 지정 연산자(::)를 이용하여 구분할 수 있다.
	네임스페이스 블록 안에서 접근할 때는 네임스페이스 접두어를 붙이지 않아도 되며. 이렇게 네임스페이스를 생략하면 코드의 가독성을 좀 더 높일 수 있다. 또한 using 지시자로 네임스페이스 접두어를 생략할 수 있는데, 컴파일러는 using 지시자를 보면 그 뒤에 나오는 문장부터는 using에 지정된 네임스페이스에 속한다고 처리하게 된다.
	하지만 using을 사용하여 네임스페이스를 전부 지우게 되면 사실상 네임스페이스가 없는것과 동일하게 되는서 남용하면 안된다. 다른 해결 방법으로는 해당 네임스페이스 안에 있는 <font color="yellow">함수를 따로 using 지시자를 사용하여 선언하는 것이 가장 효과적이다.</font>
	- 중첩 네임스페이스
		다른 네임스페이스 안에 있는 네임스페이스를 의미한다.
		==MyLibraris::Networking::FTP==
	- 네임스페이스 앨리어스
		네임스페이스 앨리어스를 사용하면 네임스페이스의 이름을 다르게 만들거나 또는 더 짧게 만들 수 있다.
		==namespace MyFTP = MyLibraris::Networking::FTP;==
- 리터럴
	코드에 표시한 숫자나 스트링과 같은 값을 의미한다. C++은 다양한 표준 리터럴을 제공한다.
	- 십진수 리터럴 : 123
	- 8진수 리터럴 : 0173
	- 16진수 리터럴 : 0x7B
	- 이진수 리터럴 : 0b1111011
	정수형이 아닌 다른 리터럴로는
	- 부동 소수점(float) : 3.14f
	- 배정도 부동 소수점(double) : 3.14
	- 16진수 부동 소수점 : 0x3.ABCp-10, 0Xb.cp121
	- 단일 문자 : 'a'
	- 0으로 끝나는 문자 배열 : "character array"
	숫자 리터럴에서는 자릿수 구분자를 사용할 수 있다. 자릿수 구분자는 작은 따옴표로 표현한다.
	- 23'456'789
	- 0.123'456f
- 변수
	변수를 선언할 때 반드시 값을 대입(초기화)할 필요는 없지만, 초기화하지 않은 변수는 선언할 시점의 메모리가 가지고있는 값을 기반으로 무작위 값이 대입될 수 있으며 해당 현상으로 버그가 발생할 가능성이 있기 때문에 초기화 해주는 것이 좋다. 초기화는 선언시에 대입연산자, 소괄호, 중괄호를 사용하여 처리할 수 있다.
	- 균일 초기화
		- 균일 초기화의 장점중 하나는 <font color="red">좁히기 변환(narrowing conversion)을 방지해준다.</font>
		  ==double x, y, z;==
		  ==int sum{ x + y + z };==
		  위와 같은 코드에서 균일 초기화를 사용하게 되면 축소변환이 불가능하게 되어 컴파일러가 에러를 발생하게 된다.
		- 또 한가지는 구문해석(most vexing parse)에서 자유롭다는 점이다. 생성자를 호출하려 할 때 컴파일러가 함수명인지 변수명인지 구분하기 어려워 발생하는 오류이다.
		  ==Widget w1(); // w1이라는 함수 선언==
		  ==Widget w2{}; // 인수 없는 생성자 호출==
		  균일 초기화를 사용하게 되면 문제없이 생성자를 호출하게 된다.<font color="yellow">사실 내 생각으로는 가독성이 떨어져보이기 때문에 사용하지 2번의 예시처럼 사용하지 않는 편이 더 좋아 보인다.</font>
	- 영 초기화
		- 변수는 유니폰 초기자(Uniform Initializer, 균일 초기자) {0}을 이용하여 0으로 초기화할 수 있다. 이때 0은 생략해도 된다. 빈 중괄호 {}로 표기한 유니폼 초기자를 영 초기자(Zero Initializer)라 한다. 영 초기자는 기본 정수 타입(char, int 등)을 0으로, 기본 부동 소수점 타입을 0.0으로, 포인터 타입을 nullptr로, 객체를 디폴트 생성자로 초기화한다.
	- 캐스트
		변수의 타입은 런타임때 바꿀 수 있다. 이를 캐스트(Cast)라 한다. C++에서 변수의 타입을 명시적으로 변환하는 방법은 세 가지다.
		- `(int)variable` : C언어에서 사용하던 것으로 C++에서는 피해야 할 방식이다.
		- `int(variable)` : 거의 사용하지 않는다.
		- `static_cast<int>(variable)` : 가장 명확해서 권장하는 방식.
		변수를 자동 캐스팅할 때 데이터가 손실될 수 있다는 점에 주희해야 한다. 
	- 부동소수점수
		소수점 자리가 다른 부동소수점수끼리 연산할 때 에러가 발생할 가능성이 있다. 또한 거의 동일한 부동소수점수끼리 뺄셈을 할 때 정밀도 손실이 발생할 수 있다.
		부동소수점수 중에는 특별한 값이 잇다.
		- +/-무한 : 예를 들어 0을 0으로 나눈 결과와 같이 양의 무한과 음의 무한을 나타낸다.
		- NaN : Npt a Number(숫자가 아님)의 줄임말이다.
		주어진 부동소수점수가 NaN인지 확인하려면 std::isnan( )을 사용한다. 무한인지 검사하려면 std::isinf( )를 사용한다. 둘 다 cmath 라이브러리에 정의되어 있다.
		이처럼 특별한 부동소수점수를 구하려면 numeric_limits를 활용한다.
- 연산자
	C++ 연산자는 표현식 두 개를 계산하는 이항(binary) 연산자, 표현식 하나만 계산하는 단항(unary) 연산자, 표현식 세 개를 계산하는 삼항(temary) 연산자로 분류할 수 있다. C++에서 삼항 연산자는 딱 하나뿐이다.
- 열거 타입
	열거 타입은 숫자를 나열하는 방식과 범위를 정의해서 변수를 선언하는 데 활용. 강타입 열거 타입을 적용하면 변수에 지정할 수 있는 값의 범위를 엄격하게 제한하기 때문에 const값을 개발자가 수정하여 발생하는 오류같은 경우를 방지할 수 있다. 
	열거형을 구성하는 멤버는 내부적으로 정수값으로 표현된다. 지장하지 않을 경우 0부터 시작하며, 지정할 경우 해당 값부터 증가하여 값이 적용된다.
	참고로 열거 타입의 값이 내부적으로 정수 표현이 된다고 해서 자동으로 정수로 변환되지는 않는다.
	기본적으로 열거 타입의 값은 정수 타입(int)로 저장되지만 내부 표현 타입을 다른 타입으로 바꿀 수 있다.
	![[Pasted image 20240105165143.png]]
	enum class로 정의한 열거 타입 값의 스코프(유효 범위)는 자동으로 확장되지 않는다. 즉, 상위 스코프에 동일한 멤버 이름이 있더라도 충돌되지 않는다. 즉, 서로 다른 열거 타입에 동일한 이름의 멤버가 존재할 수 있다.
	강타입 열거 이전에는 enum class가 아닌 enum을 사용했다. 이런 예전 방식 열거 타입의 값은 스코프가 자동으로 확장된다. 즉, 상위 스코프에서 열거 타입 멤버의 이름이 동일할 경우 충돌이 발생한다.
	따라서 예전 방식으로 열거 타입을 정의할 때는 멤버 이름을 고유한 이름으로 지정해야 한다. 이처럼 예전 방식의 열거 타입은 강타입이 아니기 때문에 타입에 안전하지 않다. 값이 항상 정수로 해석되기 때문에 열거값을 전혀 다른 열거 타입과 비교할 수도 있고, 함수를 호출할 때 열거 타입 값을 ㅈ잘못 전달하는오류가 발생할 수 있다.
- 구조체
	구조체를 사용하면 기존에 정의된 타입을 한 개 이상 묶어서 새로운 타입으로 정의할 수 있다. 
	구조체 타입으로 선언한 변수는 해당 구조체에 있는 모든 필드(field)를 가진다. 구조체를 구성하는 필드는 도트( . ) 연산자로 접근한다.
- 조건문
	- if문 초기자
		if문 안에 초기자를 넣을 수 있다.
		`if (int a = 10; a > 0) { . . . }`
	- switch문
		switch문은 조건 값이 해당하는 case문 안의 동작을 실행한다. 하지만 break문이 없다면 다음에 나오는 case문도 계속해서 실행하는데 이렇게 실행되는 것을 폴스루(fallthrough)라고 한다.
		폴스루의 경우 컴파일러는 경고 메시지를 발생한다. 의도적으로 폴스루를 발생시킨 것이라면 \[\[fallthrough]] 어트리뷰트를 지정해서 컴파일러에 알려주는 것이 좋다.
		if문처럼 switch문도 초기자를 지정할 수 있다.
		`switch (int a = 10; a) { . . . }`
- 논리 연산자
	C++은 논리 표현식을 평가할 때 단락 논리(short-circuit logic, 축약 논리)를 사용한다. 즉, 표현식을 평가하는 도중에 최종 결과가 나오면 나머지 부분은 평가하지 않는다.
	이처럼 단락 기능은 프로그램 성능을 높이는 데 도움이 된다. 단락되는 논리식을 작성할 때는 가볍게 검사할 수 잇는 부분을 앞에 적고, 시간이 좀 걸리는 부분은 뒤에 둔다. 또한 포인터값이 올바르지 않으면 그 포인터를 사용하는 표현식이 실행되지 않게 할 때도 단락을 활용하면 좋다.
- 논리 연산자
	C++은 <font color="red">논리 표현식을 평가할 때 단락 논리(short-circuit logic, 축약 논리)를 사용한다. 즉, 표현식을 평가하는 도중에 최종 결과가 나오면 나머지 부분은 평가하지 않는다.</font>
	이처럼 단락 기능은 프로그램 성능을 높이는 데 도움이 된다. 단락되는 논리식을 작성할 때는 가볍게 검사할 수 잇는 부분을 앞에 적고, 시간이 좀 걸리는 부분은 뒤에 둔다. 또한 포인터값이 올바르지 않으면 그 포인터를 사용하는 표현식이 실행되지 않게 할 때도 단락을 활용하면 좋다.
- 3방향 비교 연산자
	3방향 비교 연산자(tree-way comparison operator)는 두 값의 순서를 결정하는 데 사용된다. 이 연산자는 우주선 연산자(spaceship operator)라고도 부르는데, 연산자 기호인 <=>가 우주선처럼 생겼기 때문이다. 이 연산자는 주어진 표현식의 평가 결과가 비교 대상이 되는 값과 같은지 아니면 그보다 크거나 작은지 알려준다. 이 연산자의 반환값은 compare 라이브러리에 정의되어 있는 std 네임스페이스에 속하는 열거 타입으로 리턴한다. 피연산자가 정수 타입이면 강한 순서(strong ordering)라고 부른다.
	- strong_ordering::less : 첫 번째 피연산자가 두 번째 피연산자보다 작다.
	- strong_ordering::greater : 첫 번째 피연산자가 두 번째 피연산자보다 크다.
	- strong_ordering::equal : 두 피연산자가 같다.
	피연산자가 부동소수점 타입이라면 결과는 부분 순서(partial ordering)다.
	- partial_ordering::less : 첫 번째 피연산자가 두 번째 피연산자보다 작다.
	- partial_ordering::greater : 첫 번재 피연산자가 두 번째 피연산자보다 크다.
	- partial_ordering::equivalent : 두 피연사자가 같다.
	- partial_ordering::unordered : 두 피연산자 중 하나는 숫자가 아니다.
	또한 약한 순서(weak ordering)도 있다. 자신이 직접 정의한 타입에 대해 3방향 비교 연산을 구현할 때 이 타입을 활용할 수 있다.
	- weak_ordering::less : 첫 번째 피연산자가 두 번째 피연산자보다 작다.
	- weak_ordering::greater : 첫 번재 피연산자가 두 번째 피연산자보다 크다.
	- weak_ordering::equivalent : 두 피연산자가 같다.
	기본 타입에 대해서는 3방향 비교 연산자를 사용해도 기존 비교연산자를 사용하는 것보다 좋은 점은 없다. 하지만 비교 작업이 복잡한 객체에서는 상당히 유용하다. 이런 객체의 순서를 비교할 때 다소 무서운 기존 비교 연산자를 두 번 호출할 필요 없이 3방향 비교 연산자 하나만으로 결정할 수 있기 때문이다.
	compair 라이브러리에서는 순서의 결과를 해석해주는 이름 있는 비교 함수(named comparison function)인 std::is_eq(), is_neq(), is_lt(), islteq(), is_gt(), is_gteq()를 제공한다. 각각은 같다, 다르다, 작다, 작거나 같다, 크다, 크거나 같다로 비교한 결과를 true나 false로 리턴한다.
- 함수
	- 함수 리턴 타입 추론
		반환형으 auto 키워드로 적으면 컴파일러가 함수의 리턴 타임을 자동으로 지정해준다. 그러면 컴파일러는 return 문에 나온 표현식의 타입에 따라 리턴 타입을 추론한다. 함수 안에 return 문이 여러 개가 있다면 모두 타입이 같아야 한다. 리턴 값이 재귀 호출(recursive call)일 수도 있는데, 이때는 재귀 호출이 아닌 non-recursive return 문도 반드시 함께 있어야 한다.
	- 현재 함수 이름
		모든 함수는 내부적으로 __func__라는 로컬 변수가 정의되어 있다. 이 변수의 값은 현재 함수의 이름이며, 주로 로그를 남기는데 활용한다.
	- 함수 오버로딩
		함수를 오버로딩(overloading)한다는 말은 이름은 같지만 매개변수 구성은 다른 함수를 여러 개 제공한다는 뜻이다. 리턴 타입만 달라서는 안되며, 매개변수의 타입이나 개수도 달라야 한다.
>[!tip]
>함수를 선언하는 문장을 함수 프로토타입(function prototype, 함수 원형) 또는 함수 헤더(function header)라 부른다. 함수의 구체적인 내용은 보지 않고, 그 함수에 접근하는 방식만 표현한다는 의미가 강하다. 또한 함수의 리턴 타입을 제외한 함수 이름과 매개변수 목록을 함수 시그니처(function signature, 함수 서명)라 부른다.

- 함수
	- 함수 리턴 타입 추론
		반환형으 auto 키워드로 적으면 컴파일러가 함수의 리턴 타임을 자동으로 지정해준다. 그러면 컴파일러는 return 문에 나온 표현식의 타입에 따라 리턴 타입을 추론한다. 함수 안에 return 문이 여러 개가 있다면 모두 타입이 같아야 한다. 리턴 값이 재귀 호출(recursive call)일 수도 있는데, 이때는 재귀 호출이 아닌 non-recursive return 문도 반드시 함께 있어야 한다.
	- 현재 함수 이름
		모든 함수는 내부적으로 __func__라는 로컬 변수가 정의되어 있다. 이 변수의 값은 현재 함수의 이름이며, 주로 로그를 남기는데 활용한다.
	- 함수 오버로딩
		함수를 오버로딩(overloading)한다는 말은 이름은 같지만 매개변수 구성은 다른 함수를 여러 개 제공한다는 뜻이다. 리턴 타입만 달라서는 안되며, 매개변수의 타입이나 개수도 달라야 한다.
- 어트리뷰트
	어트리뷰트(attribute)는 소스 코드에 벤더에서 제공하는 정보나 옵션을 추가하는 메커니즘이다. C++ 표준에 어트리뷰트가 추가되기 전에는 벤더마다 이런 정보를 지정하는 방법이 달랐다. 예를 들어 `__attribute__`, `__declspec` 등을 사용했지만, C++11부터는 `[[어트리뷰트]]`와 같이 대괄호를 이용한 형식을 사용하도록 표준화되기 시작했다.
	switch case문에서 의도적으로 폴스루 방식으로 작성했을 때 컴파일러에 경고 메시지를 출력하지 말라고 알리기 위해 `[[fallthrough]]` 어트리뷰트를 사용할 수 있다.
	- `[[nodiscard]]`
		어떤 값을 리턴하는 함수에 대해 지정할 수 있다. 그러면 컴파일러는 이 함수가 호출될 때 리턴값에 아무런 작업을 하지 않으면 경고 메시지를 출력한다.
		이 기능은 에러 코드를 리턴하는 함수 등에 활용할 수 있다. 그런 함수에 `[[nodiscard]]`어트리뷰트를 붙이면 에러 코드를 무시하지 않는다.
		일반적으로 `[[nodiscard]]` 어트리뷰트는 클래스, 함수, 열거형에 적용할 수 있다.
		C++20부터 `[[nodiscard]]` 어티리뷰트에 이유를 설명하는 스트링을 추가할 수 있다.
		`[[nodiscard("Test String")]] int function() { . . . }`
	- `[[maybe_unused]]`
		뭔가 사용하지 않았을 때 컴파일러가 경고 메시지를 출력하지 않도록 설정하는 데 사용된다. ==단, 컴파일러 경고 수준이 높게 설정되어 있을 경우에만 이에 대한 경고를 출력한다.==
		`int function(int param1, [[maybe_unused]] int param2) { return 0; }`
		함수 내부에서 매개변수로 받아온 변수에 대해 아무런 연산처리가 없을 경우 발생되는 경고 메시지이다. 위와 같이 `[[maybe_unused]]` 어트리뷰트를 매개변수 앞에 선언할 경우 해당 매개변수에 한해서만 경고를 출력하지 않겠다는 어트리ㅠ트이다.
	- `[[noreturn]]`
		함수에 `[[noreturn]]` 어트리뷰트를 지정하면 호출 지점으로 다시 돌아가지 않는다. <font color="red">주로 프로세스나 스레드 종료와 같이 뭔가가 끝나게 만들거나, 익셉션을 던지는 함수가 여기에 해당한다.</font> 이 어트리뷰트를 이용하면 컴파일러가 특정한 경고나 에러 메시지를 출력하지 않게 만들 수 있다. 이 어트리뷰트를 지정하고 나면 그 함수의 용도에 대해 자세히 알게 되기 때문이다.
	- `[[likely]]`와 `[[unlikely]]`
		`[[likely]]`와 `[[unlikely]]` 어트리뷰트를 지정하면 컴파일러가 최적화 작업을 수행하는 데 도움을 줄 수 있다. 예를 들어 이 어트리뷰트를 이용하여 if와 switch 문에서 수행될 가능성이 높은 브랜치를 표시할 수 있다. 하지만 이 어트리뷰트가 필요한 경우는 드문데, 최신 컴파일러와 하드웨어는 브랜치 예측 능력이 상당히 뛰어나기 때문에 이런 어트리뷰트를 지정하지 않아도 알아서 잘 처리하기 때문이다. 하지만 성능에 민감한 부분 등과 같이 특정한 경우에는 컴파일러에 도움을 줄 수 있다.
```
if(value > 11) [[unlikely]]
{
}
else {}

switch(value)
{
	[[likely]] case 1:
		break;
	case 2:
		break;
	default:
		break;
}
```
- 어트리뷰트
	어트리뷰트(attribute)는 소스 코드에 벤더에서 제공하는 정보나 옵션을 추가하는 메커니즘이다. C++ 표준에 어트리뷰트가 추가되기 전에는 벤더마다 이런 정보를 지정하는 방법이 달랐다. 예를 들어 `__attribute__`, `__declspec` 등을 사용했지만, C++11부터는 `[[어트리뷰트]]`와 같이 대괄호를 이용한 형식을 사용하도록 표준화되기 시작했다.
	switch case문에서 의도적으로 폴스루 방식으로 작성했을 때 컴파일러에 경고 메시지를 출력하지 말라고 알리기 위해 `[[fallthrough]]` 어트리뷰트를 사용할 수 있다.
	- `[[nodiscard]]`
		어떤 값을 리턴하는 함수에 대해 지정할 수 있다. 그러면 컴파일러는 이 함수가 호출될 때 리턴값에 아무런 작업을 하지 않으면 경고 메시지를 출력한다.
		이 기능은 에러 코드를 리턴하는 함수 등에 활용할 수 있다. 그런 함수에 `[[nodiscard]]`어트리뷰트를 붙이면 에러 코드를 무시하지 않는다.
		일반적으로 `[[nodiscard]]` 어트리뷰트는 클래스, 함수, 열거형에 적용할 수 있다.
		C++20부터 `[[nodiscard]]` 어티리뷰트에 이유를 설명하는 스트링을 추가할 수 있다.
		`[[nodiscard("Test String")]] int function() { . . . }`
	- `[[maybe_unused]]`
		뭔가 사용하지 않았을 때 컴파일러가 경고 메시지를 출력하지 않도록 설정하는 데 사용된다. ==단, 컴파일러 경고 수준이 높게 설정되어 있을 경우에만 이에 대한 경고를 출력한다.==
		`int function(int param1, [[maybe_unused]] int param2) { return 0; }`
		함수 내부에서 매개변수로 받아온 변수에 대해 아무런 연산처리가 없을 경우 발생되는 경고 메시지이다. 위와 같이 `[[maybe_unused]]` 어트리뷰트를 매개변수 앞에 선언할 경우 해당 매개변수에 한해서만 경고를 출력하지 않겠다는 어트리ㅠ트이다.
	- `[[noreturn]]`
		함수에 `[[noreturn]]` 어트리뷰트를 지정하면 호출 지점으로 다시 돌아가지 않는다. <font color="red">주로 프로세스나 스레드 종료와 같이 뭔가가 끝나게 만들거나, 익셉션을 던지는 함수가 여기에 해당한다.</font> 이 어트리뷰트를 이용하면 컴파일러가 특정한 경고나 에러 메시지를 출력하지 않게 만들 수 있다. 이 어트리뷰트를 지정하고 나면 그 함수의 용도에 대해 자세히 알게 되기 때문이다.
	- `[[likely]]`와 `[[unlikely]]`
		`[[likely]]`와 `[[unlikely]]` 어트리뷰트를 지정하면 컴파일러가 최적화 작업을 수행하는 데 도움을 줄 수 있다. 예를 들어 이 어트리뷰트를 이용하여 if와 switch 문에서 수행될 가능성이 높은 브랜치를 표시할 수 있다. 하지만 이 어트리뷰트가 필요한 경우는 드문데, 최신 컴파일러와 하드웨어는 브랜치 예측 능력이 상당히 뛰어나기 때문에 이런 어트리뷰트를 지정하지 않아도 알아서 잘 처리하기 때문이다. 하지만 성능에 민감한 부분 등과 같이 특정한 경우에는 컴파일러에 도움을 줄 수 있다.
```
if(value > 11) [[unlikely]]
{
}
else {}

switch(value)
{
	[[likely]] case 1:
		break;
	case 2:
		break;
	default:
		break;
}
```
- C 스타일 배열
	배열은 같은 타입의 값을 연달아 저장하며, 각 값은 배열에서 해당 위치를 이용해 접근한다. C++에서 배열을 선언할 때는 반드시 배열의 크기를 지정해야 하는데, 변수로 지정할 수는 없고 반드시 상수 또는 상수 표현식으로 지정해야 한다. 
>[!Note]
>C++에서 배열을 표현할 C 스타일 배열보다는 표준 라이브러리에서 제공하는 std::array나 std::Vector를 사용하는 것이 좋다.	

- std::array
	C++은 std::Array라는 고정 크기 컨테이너를 제공한다. 이 타입은 array 헤더 파일에 정의되어 있다. 본질은 C 스타일 배열 위에 한꺼풀 덮어쓴 것에 불과하다.
	std::array는 C 스타일 배열에 비해 장점이 많다. 항상 크기를 정확히 알 수 있고, 자동으로 포인터 캐스트(동적 형변환)하지 않아서 특정한 종류의 버그를 방지할 수 있고, 반복자(iterator)로 배열에 대한 반복문을 쉽게 작성할 수 있다.
	선언은 `std::array<int, 3> arr`와 같이 템플릿 안에 자료형과 크기를 지정해준다.
	C++은 CTAD(calss template argument deduction, 클래스 템플릿 인수 추론)이라는 기능을 제공한다. 이것은 템플릿 타입을 지정하지 않아도 된다는 것으로 `std::array arr { 1, 2, 3 };`으로도 선언할 수 있다.
>[!Note]
>C 스타일 배열과 std::array는 둘 다 크기가 컴파일 시간에 결정되어야 하며, 실행 시간에 늘어나거나 줄어들 수 없다.


- std::vector
	vector는 C스타일의 배열 대신 사용할 수 있는 훨씬 유연하고 안전한 컨테이너이다. 원소를 모두 담을 수 있도록 메모리를 확보하는 작업은 vector 내부에서 처리되기 때문에 프로그래머가 메모리 관리를 신경 쓸 필요가 없으며, vector 는 동적 컨테이너이다. 즉, 실행 시간에 원소를 추가하거나 삭제할 수 있다는 것이다.
	vector는 제너릭 컨테이너(generic container)다. 거의 모든 종류의 객체를 담을 수 있기 때문에 vector를 사용할 때에는 템플릿 자료형을 명시해 줘야 한다. 하지만 vector 또한 CTAD를 지원한다. 그래서 템플릿 자료형을 넣는 대신 초기화를 해줌으로써 컴파일러가 해당 vector의 자료형을 추론할 수 있다.
- std::pair
	utility 헤더에 정의된 std::pair 클래스 템플릿은 두 값을 하나의 변수에 묶는다. 각 값은 public 데이터 멤버인 first, second로 접근할 수 있으며, std::pair 또한 CTAD를 지원한다.
- std::optional
	optional 헤더에 정의된 std::optional은 특정한 타입의 값을 가질 수도 있고, 아무 값도 가지지 않을 수도 있다. 
	optional은 기본적으로 함수 매개변수에 전달된 값이 없을 수도 있는 상황에 사용된다. 또한 값을 리턴할 수도 있고, 그렇지 않을 수도 있는 함수의 리턴 타입으로 사용하기도 한다. 기존에 리턴 값이 없는 경우를 표현하기 위한 nullptr, end(), -1, EOF와 같은 특수한 값을 사용하지 않아도 된다. 또한 함수의 리턴값은 수행 결과의 성공 여부를 나타내는 부울 타입으로 표현하고, 실제 결과는 출력용 매개변수를 이용하여 함수의 인수에 전달하는 식으로 작성하지 않아도 된다.(이런 매개변수는 비 const 대상을 가리키는 레퍼런스 타입으로 선언한다.)
	optional 타입은 클래스 템플릿이므로 `std::optional<int>`와 같이 템플릿 자료형을 반드시 지정해줘야 한다.
	`std::optional<int> getData(bool data) { if ( data ) { return 0; } return nullopt; }`
	이렇게 작성된 함수는 `optional<int> data1 { getData(true) };`와 같이 호출한다.
	optional에 값이 있는지 확인하려면 has_value() 메서드를 사용하거나 호출을 받은 변수가 값을 담고있는지 아닌지로 조건문을 통해 알 수 있다.
	optional에 값이 있을 때는 value()나 역참조 연산자로 그 값을 가져올 수 있다.
	값이 없을 때 value()를 호출하면 std::bad_optional_access 익셉션이 발생한다.
	value_or(x) 함수를 사용하면 값이 있을때는 해당 값을, 없을 때는 매개변수로 받은 값을 리턴한다. 이때 레퍼런스는 optional에 담을 수 없다. 레퍼런스형의 템플릿 자료형 선언도 불가능하지만, 포인터는 가능하다.
