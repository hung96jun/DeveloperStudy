- 임계 영역 문제를 해결하기 위한 고수준 소프트웨어 도구들의 종류
	- 뮤텍스 락(Mutex Locks)
		- 동기화를 위한 가장 간단한 도구
		- 세마포어와는 다르게 하나의 쓰레드만을 제어할 수 있음
		- 바이너리 세마포어라고 부를 수 있음
	- 세마포어(Semaphore)
		- 뮤텍스 락보다 더욱 강력하고, 편리하고, 효율적인 도구
		- 뮤텍스 락과는 다르게 n개의 쓰레드를 제어할 수 있음
	- 모니터(Monitor)
		- 뮤텍스락과 세마포어의 단점을 극복한 동기화 도구

1. Mutex Lock이란
	- 뮤텍스 락은 세마포어 값이 0 또는 1을 가지는 이진 세마포어(Binary Semaphore)이다.
	- 뮤텍스 락은 다른 프로세스로부터 임계 구역을 보호하고 경쟁 상태(Race Condition)을 예방한다.
	- 뮤텍스 락을 이용하는 프로세스들은 임계 구역 입장 전 Lock을 얻어야 하고 임계 구역을 나가게 되면 Lock을 해제해야 한다.
	
	- Mutex Lock의 두 연산과 변수
		- acquire() : Lock을 얻는 연산
		- release() : Lock을 방출하는 연산
		- available : Lock을 얻을 수 있는지 없는지 나타내는 bool 변수
			- available == true : 임계 영역 입장 가능
			- available == false : 임계 영역 입장 불가. 바쁜 대기(Busy Waiting)을 수행
	- Mutex Locks를 사용한 임계 영역 문제 해결![[Pasted image 20240321194629.png]]
		- Entry Section : acquire lock 연산을 수행하여 lock을 얻어 임계 영역에 들어가고자 한다.
		- Exit Section : release lock 연산을 수행하여 임계 영역에서 작업을 마치고 lock을 반납한다.
	- acquire() 연산과 release() 연산의 정의![[Pasted image 20240321194912.png]]
		- acquire() 연산과 release() 연산은 다른 쓰레드들이 선점할 수 없도록 원자적(atomically)으로 수행되어야 한다.
		- acquire() 연산과 release() 연산은 compare_and_swap 연산을 기반으로 구현할 수 있다.
	- 바쁜 대기(Busy Waiting)이란
		- 바쁜 대기란 한 프로세스가 자신의 임계 구역에 있으며, 자신의 임계 구역에 진입하려는 다른 프로세스가 진입 코드를 계속 반복 수행(무한 루프)하는 것을 의미한다.
		- 바쁜 대기는 다른 프로세스들이 생산적으로 사용할 수 있는 CPU 코어를 낭비하게 된다.
		- 프로세스가 lock을 기다리는 동안 회전하기 때문에 이런 유형의 세마포어 스핀 락(spinlock)이라고 부르기도 한다.
	- 스핀 락(spinlock)
		- 바쁜 대기(Busy Waiting) 방식을 이용한 뮤텍스 락의 잠금 유형이다.
		- 프로세스는 lock을 얻을 때까지 대기하는 동안 반복문을 반복한다.
		- 스핀락의 장점
			- lock을 얻기 위해 대기하는 동안 문맥 교환(Context Switch)가 요구되지 않는다. 이유는 문맥 교환은 상당한 시간이 소요될 수 있기 때문이다.
			- 스핀 락은 멀티코어 시스템의 특정한 상황에서 락킹(locking)을 위한 선호되는 선택이 될 수 있다.
			- 하나의 쓰레드가 하나의 CPU 코어에서 스핀을 하는 반면 다른 쓰레드는 다른 CPU 코어에서 임계 영역의 작업을 수행할 수 있다.
	- Mutex Lock 예제
		![[Pasted image 20240321200000.png]]
2. 세마포어란
	- 세마포어도 뮤텍스 락과 마찬가지로 여러 스레드가 동시에 공유 자우원에 접근하는 것을 막기 위한 동기화 도구이다.
	- 세마포어의 사용 이유
		- 하드웨어 기반의 해결안(test_and_set, compare_and_set)은 사용하기 복잡하기 때문이다.
	
	- 세마포어의 연산
		- wait() : 쓰레드가 임계 구역에 들어가기 위ㅐ 호출하는 연산. 다른 쓰레드가 임계 구역에 작업중이면 대기한다.
		- signal() : 쓰레드가 임계 구역에 작업을 마치고 세마포어를 해제하는 연산이다.
	- wait()과 signal()의 정의![[Pasted image 20240321200217.png]]
		- wait()과 signal() 연산의 주목할 점은 두 연산이 수행할 때 세마포어의 값을 수정하는 동안 다른 쓰레드가 선점할 수 없다는 점이다.
		- wait()과 signal() 연산은 원자적(atomically)하게 수행된다.
	- 세마포어의 구현
		![[Pasted image 20240321200651.png]]
		wait() 연산은 다음과 같이 구현할 수 있다.
		![[Pasted image 20240321200712.png]]
		signal() 연산은 다음과 같이 구현할 수 있다.
		![[Pasted image 20240321200731.png]]
		- block()  : 자기를 호출할 프로세스를 중지시킴. 중지시킨 프로세스는 대기 큐(waiting queue)에 들어가게 된다.
		- wakeup(P) : 봉쇄된 프로세스 P의 실행을 재개시킴. 재개된 프로세스느 준비 큐(ready queue)에 들어가게 된다.
	- 세마포어의 예제
	![[Pasted image 20240321200838.png]]
	위 예제는 바이너리 세마포어로써 Mutex Lock의 예제와 동일하다.
	![[Pasted image 20240321200908.png]]
	위 예제는 세마포어 초기값을 5로 설정한 예제이다. 5로 설정해서 여러 개의 프로세스들이 동시에 임계 구역에 들어갈 수 있기 때문에 동기화 오류가 발생한다. 하지만 5개의 쓰레드가 하나의 공유 자원인 sum에 접근하여 값을 변경하는 것이 아닌 5개의 공간을 가지는 sum 배열을 가지고 각각의 쓰레드가 하나의 공간을 맡아서 수행한다면 동기화 오류를 고칠 수 있을 것이다. 그래서 위의 예제와 같은 경우 5개의 세마포어가 아닌 1개의 세마포어로 바꾸는 것이 하나의 sum 변수에 대한 올바른 의도일 것이다.