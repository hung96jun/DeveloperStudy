일단 호출 스택을 먼저 알아야 한다. 프로그램은 메인 함수를 시작점으로 많은 함수가 실행되며 그 함수들은 또 다른 함수들을 실행한다. 함수는 실행이 끝나면 ==자신을 호출했던 지점으로 되돌아가야 하는데==, 이 정보가 저장된 곳을 <font color="red">호출 스택</font>이라 하며 안에는 각 함수 안에 선언된 지역 변수도 같이 들어 있다.

==스레드는 실행 지점이 서로 다를 수 밖에 없다.== 스레드를 생성하려면 운영체제나 런타임 라이브러리에서 제공하는 스레드 생성용 함수를 호출하고 함수 인자로 ==스레드가 최초로 실행할 함수와 매개변수==를 넣어준다. 이때, 함수 인자에 따라 각 스레드의 실행 지점이 서로 달라지며 같은 함수를 실행한다 하더라도 인자나 메모리 상태 등이 다르므로 결국 다른 실행 지점을 가리키게 된다.
![[Pasted image 20231027064148.png|400]]
따라서 각 스레드마다 다른 실행 지점을 지정하기 위해 호출 스택을 따로 저장해야 한다.
![[Pasted image 20231027064218.png|400]]
(메인 스레드와 또 다른 스레드가 동시에 작동하는 예제 코드)
- 프로그램이 실행하면, 메인 스레드의 실행 지점은 (1)부터 시작한다.
- CreateThread()는 새로운 스레드 하나를 생성하는데, 매개변수로 다른 함수와 그 함수가 받을 매개변수를 요구한다.
- 메인 스레드가 다음 일을 처리하는 동안 스레드1도 함수를 실행한다.(어떤 것이 먼저 실행될지는 모른다.)
- Join()은 해당 스레드의 일이 끝날때까지 메인 스레드를 기다리게 한다.(메인 스레드가 먼저 종료되지 않도록 주의해야 한다.)
- 스레드 1의 함수가 종료되면 스레드 1은 소멸되고 메인 스레드도 다시 깨어나게 된다.
- 실행된 프로세스 안의 모든 스레드가 종료되었으므로 프로세스 자체가 종료한다.
![[Pasted image 20231027064457.png|400]]
--------------
멀티 스레드 프로그래밍을 남용하게 되면 오히려 비효율적인 프로그램이 될 수 있다. 뿐만 아니라 조금만 실수해도 심각한 오류를 일으키며 심지어 오류를 찾기 힘들 때도 많다.
- 오래 걸리는 일 하나와 빨리 끝나는 일 여럿을 같이 해야 할 때 : 게임 로딩을 하는 동안 사용자의 지루함을 덜기 위해 그래프나 애니메이션 등응 렌더링 할 수 있다.
- 어떤 긴 처리를 진행하는 동안 다른 짧은 일을 처리해야 할 때 : 플레이어의 정보를 읽거나 쓰려고 디스크를 엑세스 하는 경우 해당 스레드는 디스크의 처리 결과가 끝날 때까지 기다려야 한다. 이때, 다른 플레이어에게 분배하면 서버의 실행 성능을 개선할 수 있다.
- 기기에 있는 CPU를 모두 활용해야 할 때 : 기본적으로 스레드는 하나의 코어를 사용한다. 예를 들어 8코어 CPU에서 싱글 스레드 프로그램을 만든다면, 서버는 전체 연산 성능의 1/8만 사용할 것이다.
-------------
경쟁 상태를 해결하는 여러방법 중 하나는 ==다른 스레드는 X를 건드리려고 하면 현재 스레드가 X를 다 사용할 때 까지 기다리는 것==

이때 사용하는 것이 <font color="red">뮤텍스(Mutex)</font>이다.
- 뮤텍스는 상호 배제(Mutual Exclusion)의 줄임말
- 뮤텍스는 다른 말로 임계 영역(Critical Section)이라고 함
```C++
std::mutex mx;
mx.lock();
read(x);
write(y);
sum(x);
mx.unlock();
```
- 스레드 1이 lock함수를 사용하여 뮤텍스 사용권을 얻는데에 성공하면 read 함수로 넘어감
- 다른 스레드2가 이미 뮤텍스 사용권을 얻은 상태면 스레드1은 더이상 진행하지 못하고 정지
- 스레드2가 read, write, sum 함수를 사용하고 난 후 lock함수로 넘어가는데 그때 스레드 1은 뮤텍스 사용권을 얻어 read 함수로 넘어감

위 상황에서 lock과 unlock을 호출하는 것은 번거롭고 예외코드 작성도 어려움. read 함수를 실행하다 예외가 발생하면 그 후의 과정은 실행되지 않게됨. 이를 해결하려면 예외가 발생하더라도 unlock()을 실행할 수 있게 해줘야한다.
```C++
std::recursive_mutex mx;
lock_guard<recursive_mutex> lock(mx);
read(x);
write(x);
sum(x);
```
C++은 뮤텍스 잠금 상태를 로컬 변수로 저장하고, 그 변수가 사라질 때 자동으로 잠금 해제가 되게 하는 lock_guard 클래스를 제공한다. 이 클래스를 사용하면 lock객체가 사라질 때 자동으로 unlock()이 실행된다.
```C#
object mx = new objec();
lock(mx)
{
	read(x);
	write(y);
	sum(x);
}
```

>[!example] 예제
>![[Pasted image 20231103155652.png]]

위 예제를 실행했을 때, 스레드가 하나일 경우 실행 시간이 3900밀리 초 정도인데, 스레드가 4개일때는 1300밀리초이다. 이론적으로 4배가 빨라져야하는데 3배밖에 빨라지지 않는 이유는
- lock에 걸려 다른 스레드가 대기 상태로 전환하는 상황 발생
- CPU는 메모리 액세스 시간이 길어, 멀티스레드가 작동하더라도 메모리에 접근하는 동안에는 CPU갯수보다 더 적은 수의 CPU를 처리하게 됨
위와 같은 상황을 해결하기 위해 뮤텍스를 최대한 나누게 되면
- 뮤텍스를 액세스 하는 과정이 무겁기 때문에 오히려 프로그램 성능이 떨어짐
- <font color="red">교착상태</font>가 쉽게 발생함
특히 교착상태 문제는 심각하기 때문에 뮤텍스는 어느 정도 굵직하게 잠금 범위를 잡아줘야함
반대로 뮤텍스가 보호나는 영역이 너무 넓으면 스레드가 여럿이라 하더라도 하나일 경우와 큰 차이가 없어짐.
따라서, ==동시에 연산하려면 유리한 부분을 잠금 단위로 나누고 병렬로 하지 않아도 성능에 영향을 주지 않는 부분들을 잠금 단위를 나누지 않는것이 좋음==

-----------------
교착 상태
멀티스레드 프로그래밍에서 교착 상태란 <font color="red">두 스레드가 서로를 기다리는 상황</font>을 의미. 이러한 경우 두 스레드는 여원히 멈춰있게된다.![[Pasted image 20231103161208.png]]
뮤텍스가 여럿일 때 교착상태가 발생하지 않도록 하기 위해 잠금 순서의 규칙을 만들어야함

---
잠금 순서의 규칙
교착 상태를 예방하려면
- 각 뮤텍스의 잠금 순서를 먼저 그래프로 그린다.
- 잠금을 할때는 잠금 순서 그래프를 보면서 ==거꾸로 잠근 것이 없는지 체크==한다.
	- A->B->C 순서일 경우 lock(A->B->C), unlock(C->B->A)가 되어야 하며, lock(C->B->A)가 될경우 교착상태가 발생된다.
- ==잠금을 해제하는 순서는 교착 상태에 양향을 주지 않는다==
- 뮤텍스는 재귀성을 가질 수 있으므로 주의해야 한다.
	- 재귀 뮤텍스는 한 스레드가 뮤텍스를 여러 번 반복해서 잠그는 것을 허락함으로, 여러 번 잠그게 되면 그만큼 해제가 필요함
		- 첫 잠금에서 순서를 어길경우 교착 상태가 발생
		- 이미 잠근 것에 대한 재귀 잠금은 잠금 순서 그래프와 상관없음

---
병렬성과 시리얼 병목
- <font color="red">병렬성</font> : ==여러 CPU가 각 스레드의 연산을 실행하여 동시에 처리량을 올리는 것==
- <font color="red">시리얼 병목</font> : 병렬성이 제대로 나오지 않는 것, 즉 ==병렬로 실행되게 프로그램을 만들었는데 정작 한 CPU 연산을 수행하는 현상==

뮤텍스로 잠근 구간을 다른 스레드가 실행하려 하면 그 스레드는 일시정지 상태가 됨. 따라서 ==극단적인 경우 여러 CPU가 병렬처리를 하더라도 실제로는 CPU 1개를 제외하고 나머지 CPU에는 노는 구간이 발생하게 됨==

==CPU 갯수가 많아질수록== 빈 공간은 넓어지며, 병렬로 처리할 수 없는 구간, 즉 ==시리얼 병목이 존재하는 시간이 길어질수록 총 처리량은 줄어들게 된다.== 이처럼 시리얼 병목이 있을 때, CPU가 많을수록 총 처리 효율성이 떨어지는 현상을 <font color="red">암달의 법칙 혹은 암달의 저주</font>라고 한다.
암달의 저주를 줄이러면 시리얼 병목이 발생하는 구간을 최소로 줄여야 한다.

>[!tip] Concurrency Visualizer
>Visual Studio의 Concurrency Visualizer는 ==멀티스레드 프로그램이 여러 가지 일을 정말 잘 수행하는지 분석하여 이를 시각화해서 보여주는 도구==이다. 이 도구를 활용하면 서능의 병목을 쉽게 찾아낼 수 있다.
>![[Pasted image 20231103162247.png]]
>- 디버거 없이 프로그램 실행 후 Analyze ->Concurrency Visualizer -> Attach to Process로 분석 시작
>- 분석을 시작하고 몇 초 후 중지 버튼을 누르고 새 창이 뜨면 1을 누름
>- 2는 각 스레드가 무슨 일을 했는지 그래프로 보여줌
>- 3은 해당 구간 동안 각 스레드가 한 일의 통계를 보여줌
>	- 94%가 Excution이라는 의미는 일한 시간의 94%가 CPU 연산을 하고 있다는 것으로 매우 양호한 상태
>	- Synchronlization이란 뮤텍스를 이미 다른 스레드로 잠근 상태라 기다리는 동안의 시간을 의미
>- 4는 스레드 4개가 각각 무엇을 했는지 보여줌


병령 병목이 발생하는 흔한 경우
- 디바이스 타임 : 기기에 있는 장치에 뭔가를 요청해서 결과가 나올때 까지 기다리는 시간
	- 스레드는 잠자는 상태이므로 디바이스 타임 동안에는 CPU가 연산을 하지 않고 자기 때문에 시간이 낭비됨. 따라서 다른 스레드를 위한 CPU 연산을 하는 것이 효율적
- CPU 타임 : 뮤텍스 잠금을 하지 않느다. 단, 디바이스 타임 동안 값이 변경되었을 가능성이 있으니, 뮤텍스 잠금 후 변수의 상태 체크를 다시 해야함
