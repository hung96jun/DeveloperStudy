일단 호출 스택을 먼저 알아야 한다. 프로그램은 메인 함수를 시작점으로 많은 함수가 실행되며 그 함수들은 또 다른 함수들을 실행한다. 함수는 실행이 끝나면 ==자신을 호출했던 지점으로 되돌아가야 하는데==, 이 정보가 저장된 곳을 <font color="red">호출 스택</font>이라 하며 안에는 각 함수 안에 선언된 지역 변수도 같이 들어 있다.

==스레드는 실행 지점이 서로 다를 수 밖에 없다.== 스레드를 생성하려면 운영체제나 런타임 라이브러리에서 제공하는 스레드 생성용 함수를 호출하고 함수 인자로 ==스레드가 최초로 실행할 함수와 매개변수==를 넣어준다. 이때, 함수 인자에 따라 각 스레드의 실행 지점이 서로 달라지며 같은 함수를 실행한다 하더라도 인자나 메모리 상태 등이 다르므로 결국 다른 실행 지점을 가리키게 된다.
![[Pasted image 20231027064148.png|400]]
따라서 각 스레드마다 다른 실행 지점을 지정하기 위해 호출 스택을 따로 저장해야 한다.
![[Pasted image 20231027064218.png|400]]
(메인 스레드와 또 다른 스레드가 동시에 작동하는 예제 코드)
- 프로그램이 실행하면, 메인 스레드의 실행 지점은 (1)부터 시작한다.
- CreateThread()는 새로운 스레드 하나를 생성하는데, 매개변수로 다른 함수와 그 함수가 받을 매개변수를 요구한다.
- 메인 스레드가 다음 일을 처리하는 동안 스레드1도 함수를 실행한다.(어떤 것이 먼저 실행될지는 모른다.)
- Join()은 해당 스레드의 일이 끝날때까지 메인 스레드를 기다리게 한다.(메인 스레드가 먼저 종료되지 않도록 주의해야 한다.)
- 스레드 1의 함수가 종료되면 스레드 1은 소멸되고 메인 스레드도 다시 깨어나게 된다.
- 실행된 프로세스 안의 모든 스레드가 종료되었으므로 프로세스 자체가 종료한다.
![[Pasted image 20231027064457.png|400]]
--------------
멀티 스레드 프로그래밍을 남용하게 되면 오히려 비효율적인 프로그램이 될 수 있다. 뿐만 아니라 조금만 실수해도 심각한 오류를 일으키며 심지어 오류를 찾기 힘들 때도 많다.
- 오래 걸리는 일 하나와 빨리 끝나는 일 여럿을 같이 해야 할 때 : 게임 로딩을 하는 동안 사용자의 지루함을 덜기 위해 그래프나 애니메이션 등응 렌더링 할 수 있다.
- 어떤 긴 처리를 진행하는 동안 다른 짧은 일을 처리해야 할 때 : 플레이어의 정보를 읽거나 쓰려고 디스크를 엑세스 하는 경우 해당 스레드는 디스크의 처리 결과가 끝날 때까지 기다려야 한다. 이때, 다른 플레이어에게 분배하면 서버의 실행 성능을 개선할 수 있다.
- 기기에 있는 CPU를 모두 활용해야 할 때 : 기본적으로 스레드는 하나의 코어를 사용한다. 예를 들어 8코어 CPU에서 싱글 스레드 프로그램을 만든다면, 서버는 전체 연산 성능의 1/8만 사용할 것이다.
-------------
경쟁 상태를 해결하는 여러방법 중 하나는 ==다른 스레드는 X를 건드리려고 하면 현재 스레드가 X를 다 사용할 때 까지 기다리는 것==

이때 사용하는 것이 <font color="red">뮤텍스(Mutex)</font>이다.
- 뮤텍스는 상호 배제(Mutual Exclusion)의 줄임말
- 뮤텍스는 다른 말로 임계 영역(Critical Section)이라고 함
```C++
std::mutex mx;
mx.lock();
read(x);
write(y);
sum(x);
mx.unlock();
```
- 스레드 1이 lock함수를 사용하여 뮤텍스 사용권을 얻는데에 성공하면 read 함수로 넘어감
- 다른 스레드2가 이미 뮤텍스 사용권을 얻은 상태면 스레드1은 더이상 진행하지 못하고 정지
- 스레드2가 read, write, sum 함수를 사용하고 난 후 lock함수로 넘어가는데 그때 스레드 1은 뮤텍스 사용권을 얻어 read 함수로 넘어감

위 상황에서 lock과 unlock을 호출하는 것은 번거롭고 예외코드 작성도 어려움. read 함수를 실행하다 예외가 발생하면 그 후의 과정은 실행되지 않게됨. 이를 해결하려면 예외가 발생하더라도 unlock()을 실행할 수 있게 해줘야한다.
```C++
std::recursive_mutex mx;
lock_guard<recursive_mutex> lock(mx);
read(x);
write(x);
sum(x);
```
C++은 뮤텍스 잠금 상태를 로컬 변수로 저장하고, 그 변수가 사라질 때 자동으로 잠금 해제가 되게 하는 lock_guard 클래스를 제공한다. 이 클래스를 사용하면 lock객체가 사라질 때 자동으로 unlock()이 실행된다.
```C#
object mx = new objec();
lock(mx)
{
	read(x);
	write(y);
	sum(x);
}
```

>[!example] 예제
>![[Pasted image 20231103155652.png]]

위 예제를 실행했을 때, 스레드가 하나일 경우 실행 시간이 3900밀리 초 정도인데, 스레드가 4개일때는 1300밀리초이다. 이론적으로 4배가 빨라져야하는데 3배밖에 빨라지지 않는 이유는
- lock에 걸려 다른 스레드가 대기 상태로 전환하는 상황 발생
- CPU는 메모리 액세스 시간이 길어, 멀티스레드가 작동하더라도 메모리에 접근하는 동안에는 CPU갯수보다 더 적은 수의 CPU를 처리하게 됨
위와 같은 상황을 해결하기 위해 뮤텍스를 최대한 나누게 되면
- 뮤텍스를 액세스 하는 과정이 무겁기 때문에 오히려 프로그램 성능이 떨어짐
- <font color="red">교착상태</font>가 쉽게 발생함
특히 교착상태 문제는 심각하기 때문에 뮤텍스는 어느 정도 굵직하게 잠금 범위를 잡아줘야함
반대로 뮤텍스가 보호나는 영역이 너무 넓으면 스레드가 여럿이라 하더라도 하나일 경우와 큰 차이가 없어짐.
따라서, ==동시에 연산하려면 유리한 부분을 잠금 단위로 나누고 병렬로 하지 않아도 성능에 영향을 주지 않는 부분들을 잠금 단위를 나누지 않는것이 좋음==

-----------------
교착 상태
멀티스레드 프로그래밍에서 교착 상태란 <font color="red">두 스레드가 서로를 기다리는 상황</font>을 의미. 이러한 경우 두 스레드는 여원히 멈춰있게된다.![[Pasted image 20231103161208.png]]
뮤텍스가 여럿일 때 교착상태가 발생하지 않도록 하기 위해 잠금 순서의 규칙을 만들어야함

---
잠금 순서의 규칙
교착 상태를 예방하려면
- 각 뮤텍스의 잠금 순서를 먼저 그래프로 그린다.
- 잠금을 할때는 잠금 순서 그래프를 보면서 ==거꾸로 잠근 것이 없는지 체크==한다.
	- A->B->C 순서일 경우 lock(A->B->C), unlock(C->B->A)가 되어야 하며, lock(C->B->A)가 될경우 교착상태가 발생된다.
- ==잠금을 해제하는 순서는 교착 상태에 양향을 주지 않는다==
- 뮤텍스는 재귀성을 가질 수 있으므로 주의해야 한다.
	- 재귀 뮤텍스는 한 스레드가 뮤텍스를 여러 번 반복해서 잠그는 것을 허락함으로, 여러 번 잠그게 되면 그만큼 해제가 필요함
		- 첫 잠금에서 순서를 어길경우 교착 상태가 발생
		- 이미 잠근 것에 대한 재귀 잠금은 잠금 순서 그래프와 상관없음

---
병렬성과 시리얼 병목
- <font color="red">병렬성</font> : ==여러 CPU가 각 스레드의 연산을 실행하여 동시에 처리량을 올리는 것==
- <font color="red">시리얼 병목</font> : 병렬성이 제대로 나오지 않는 것, 즉 ==병렬로 실행되게 프로그램을 만들었는데 정작 한 CPU 연산을 수행하는 현상==

뮤텍스로 잠근 구간을 다른 스레드가 실행하려 하면 그 스레드는 일시정지 상태가 됨. 따라서 ==극단적인 경우 여러 CPU가 병렬처리를 하더라도 실제로는 CPU 1개를 제외하고 나머지 CPU에는 노는 구간이 발생하게 됨==

==CPU 갯수가 많아질수록== 빈 공간은 넓어지며, 병렬로 처리할 수 없는 구간, 즉 ==시리얼 병목이 존재하는 시간이 길어질수록 총 처리량은 줄어들게 된다.== 이처럼 시리얼 병목이 있을 때, CPU가 많을수록 총 처리 효율성이 떨어지는 현상을 <font color="red">암달의 법칙 혹은 암달의 저주</font>라고 한다.
암달의 저주를 줄이러면 시리얼 병목이 발생하는 구간을 최소로 줄여야 한다.

>[!tip] Concurrency Visualizer
>Visual Studio의 Concurrency Visualizer는 ==멀티스레드 프로그램이 여러 가지 일을 정말 잘 수행하는지 분석하여 이를 시각화해서 보여주는 도구==이다. 이 도구를 활용하면 서능의 병목을 쉽게 찾아낼 수 있다.
>![[Pasted image 20231103162247.png]]
>- 디버거 없이 프로그램 실행 후 Analyze ->Concurrency Visualizer -> Attach to Process로 분석 시작
>- 분석을 시작하고 몇 초 후 중지 버튼을 누르고 새 창이 뜨면 1을 누름
>- 2는 각 스레드가 무슨 일을 했는지 그래프로 보여줌
>- 3은 해당 구간 동안 각 스레드가 한 일의 통계를 보여줌
>	- 94%가 Excution이라는 의미는 일한 시간의 94%가 CPU 연산을 하고 있다는 것으로 매우 양호한 상태
>	- Synchronlization이란 뮤텍스를 이미 다른 스레드로 잠근 상태라 기다리는 동안의 시간을 의미
>- 4는 스레드 4개가 각각 무엇을 했는지 보여줌


병령 병목이 발생하는 흔한 경우
- 디바이스 타임 : 기기에 있는 장치에 뭔가를 요청해서 결과가 나올때 까지 기다리는 시간
	- 스레드는 잠자는 상태이므로 디바이스 타임 동안에는 CPU가 연산을 하지 않고 자기 때문에 시간이 낭비됨. 따라서 다른 스레드를 위한 CPU 연산을 하는 것이 효율적
- CPU 타임 : 뮤텍스 잠금을 하지 않느다. 단, 디바이스 타임 동안 값이 변경되었을 가능성이 있으니, 뮤텍스 잠금 후 변수의 상태 체크를 다시 해야함

---
멀티스레드 게임 서버
멀티 스레드로 서버를 개발하는 경우
- 서버 프로세스를 많이 띄우기 힘들 때 : 프로세스당 로딩해야 하는 게임 정보의 용량이 매우 클때
- 서버 한 대의 프로세스가 여러 CPU의 연산량을 동원해야 할만큼 많은 연산을 할 때
- 코루틴이나 비동기 함수를 쓸 수 없고 디바이스 타임이 발생할 때
- 서버 인스턴스를 서버 기기당 하나만 두어야 할 때
- 서로 다른 방이 같은 메모리 공간을 액세스 해야 할 때
```C++
class SingleThreadServer
{
	class Room
	{
		string roomName;
		List<Player> players;
		List<Character> characters;
	}

	map<PlayerID, shared_ptr<Room>> roomList;
	string serverName;
}

class MultiThreadServer
{
	class Room
	{
		CriticalSection critSection;
		string roomName;
		List<Player> players;
		List<Character> characters;
	}

	map<PlayerID, shared_ptr<Room>> roomList;
	string serverName;
	CriticalSection critSection;
}
```
- 게임 서버 메인은 방 목록을 가지며 방 목록에는 각 방에 들어간다.
- 각 방은 뮤텍스를 가지며 또 게임 서버 메인 자체도 뮤텍스를 가진다.
- 플레이어 행동에 대한 처리는 각 방을 잠근 후에 동작
	- 공통 데이터(방 목록 등)를 잠금
	- 플레이어 A가 들어 있는 방을 방 목록에서 찾는다.
	- 공통 데이터를 잠금 해제한다.
	- 찾은 방을 잠근다.
	- 플레이어 A의 방 안에서 처리를 한다.
	- 방을 잠금 해제한다.
```C++
JoinServer(playerID)
{
	lock(critSection);
	room = roomList.find(player);
	Unlock(critSection);

	lock(room.critSection);
	roomJoinSection(playerID);
	Unlock(room.critSection);
}
```

---
스레드 풀링
멀티 스레드 모델의 게임 서버를 만들 때 게임 서버는 클라이언트마다 스레드를 배정해 주는 것이 가장 쉽다. 단, 개발은 쉬워지지만 스레드 개수가 매우 많아지므로 여러 가지 문제가 발생할 가능성이 높음.
- 각 스레드는 호출 스택을 가지는데 이를 저장할 메모리 공간이 매우 커짐
- 컨텍스트 스위치 연산은 무거운 작업인데 이를 매우 자주 동작시켜줘야 함.
이러한 문제로 인해 위 방법을 사용하지 않고 <font color="red">스레드 풀링</font>을 많이 사용한다.

스레드 풀링은, ==모든 스레드가 사용중일 경우 이벤트를 대기시키고, 사용중이 아닌 스레드가 하나라도 있으면 대기중 이벤트를 동작시킨다.== 이럴 경우 ==많은 수의 이벤트를 동시에 여러 스레드에서 처리==할 수 있으며, 너무 많은 스레드를 두었을 때 발생하는 문제점을 방지할 수 있다.
- 어떤 서버의 주 역할이 디바이스 타임이 없고, CPU 연산만 하는 스레드라면, 스레드 풀의 스레드 갯수는 CPU 갯수와 동일하게 잡아도 충분
- 서버에서 데이터베이스나 파일 등 다른 것에 액세스 하면서 디바이스 타임이 발생할 때 스레드 갯수는 CPU 갯수보다 많아야 한다.

---
이벤트
멀티 스레드 프로그래밍을 위한 또 다른 도구. 
이벤트는 ==대기중 스레드를 깨우는 도구==로 Reset(이벤트 없음, 0), Set(이벤트 있음, 1) 상태 값을 가진다.
```C++
Event event1; void Thread1() 
{ 
	// 이벤트가 신호를 일으킬 때까지 기다린다. 
	event1.Wait(); 
} 

void Thread2() 
{ 
	// 이벤트에 신호를 준다. 
	event1.SetEvent(); 
}
```
- CreateEvent : 이벤트를 생성
- CloseHandle : 이벤트를 파괴
- WaitForSingleObject : 이벤트를 대기
- SetEvent : 이벤트에 신호를 줌
이벤트는 ==스레드 간 소통하며 일을 처리해야 할 때 유용==하다.

---
세마포어
멀티 스레드 프로그래밍을 위한 또 다른 도구. 
==뮤텍스나 임계 영역은 오로지 스레드 1개==만 자원을 액세스 할 수 있게 한다. 하지만 세마포어는 ==원하는 갯수의 스레드가 자원을 액세스== 할 수 있게 한다.
```C++
Semaphore sema1;

void main()
{
	// 스레드 2개만 자원을 액세스 할 수 있게 제한
	sema1 = new Semaphore(2);
}

void Thread1()
{
	// 리소스를 액세스할 수 있을 때까지 대기
	sema1.Wait();

	// 리소스 액세스가 다 끝났음을 세마포어에 알림
	sema1.Release();
}

void Thread2()
{
	// 리소스를 액세스할 수 있을 때까지 대기
	sema1.Wait();

	// 리소스 액세스가 다 끝났음을 세마포어에 알림
	sema1.Release();
}

void Thread3()
{
	// 리소스를 액세스할 수 있을 때까지 대기
	sema1.Wait();

	// 리소스 액세스가 다 끝났음을 세마포어에 알림
	sema1.Release();
}
```
- CreateSemaphore : 세마포어를 생성하고 자원을 몇 개 허락하는지 설정
- WaitForSingleObject : 세마포어가 자원 액세스를 요청, 허락할 때까지 대기
- ReleaseSemaphore : 세마포어에 자원 액세스가 끝났음을 통보
- CloseHandle : 세마포어를 파괴
세마포어는 상태 값을 갖고 있으며 초기 값은 설정했던 최대 액세스 가능한 스레드 갯수. 스레드가 세마포어에 자원 액세스를 요청하면 상태 값을 1 갑소하며, 자원 액세스가 끝난 후엔 1 증가. 세마포어와 이벤트는 비슷하지만 이벤트는 상태 값이 0, 1로 제한되지만 세마포어는 0 이상의 값이란 차이가 생김.

---
원자 조작
멀티 스레드 프로그래밍을 위한 또 다른 도구.
원자 조작은 뮤텍스나 임계 영역 잠금 없이도 여러 스레드가 안전하게 접근할 수 있는 것을 의미.
하드웨어 기능이며 대부분의 컴파일러는 워낮 조작 기능을 사용할 수 있게 한다.

---
멀티 스레드 프로그래밍의 흔한 실수들
- 읽기와 쓰기 모두에 잠금하지 않기
	그냥 값을 읽고만 있으면 잠금을 하지 않더라도 안전하다는 막연한 생각 때문에 발생.
	크래시를 일으키지는 않지만 값이 이상하게 출력될 수 있음.
- 잠금 순서 꼬임
	프로그램 규모가 커지면 이 규칙을 준수하기 어려움
	제일 좋은 것은 잠금 순서 규칙을 최대한 적게 유지하는 것.
- 너무 좁은 잠금 범위
	잠금 객체 범위가 너무 넓으면 컨텍스트 스위치가 발생할 때 운영체제가 해야 할 일이 많아지고 병렬성이 떨어짐. 잠금 범위를 좁히면 컨텍스트 스위치의 확률이 떨어지기는 하지만 임계 영역 잠금이 더 많은 처리 시간을 차지. 따라서 임계 영역을 적당한 수준에서 나눠줘야 좋다.
- 디바이스 타임이 섞인 잠금
	디바이스 타임이 있을 때는 다른 스레드가 자주 접근하는 리소스에 대한 잠금을 하지 말아야 한다. 특히 자주 하는 실수는 로그 출력이나 콘솔 출력이다. 동시 접속자는 많은데 게임 서버에서 CPU 사용량이 적게 나오는 경우, 이 때문인 경우가 있다.
- 잠금의 전염성으로 발생한 실수
	잠금으로 보호되는 리소스에서 얻어 온 값이나 포인터 주소 값 등이 로컬 변수로 있는 경우에도 잠금 상태를 계속 유지해야 할 때가 있다.
- 잠금된 뮤텍스나 임계 영역 삭제
- 일관성 규칙 깨기
	만일 변수 여러개가 연관되어 일관성을 유지시켜야 하는 경우 잠금 객체가 그많큼 생기기 때문에 일관성이 유지되지 못한다.(?)

---
