- 동적 계획법은 기본적인 아이디어로 <font color="red">하나의 큰 문제를 여러 개의 작은 문제로 나누어 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하</font>는 것으로 특정한 알고리즘이 아닌 하나의 문제 패러다임으로 불 수 있다.
	- 큰 문제를 작은 문제로 쪼개서 그 답을 저장해두고 재활용한다.
- 사용 조건
	- Overlapping Subproblems : 겹치는 부분 문제
	- Optimal Substructure : 최적 부분 구조
- Overlapping Subproblems
	- DP는 기본적으로 문제를 나누고 그 문제의 결과값을 재활용해서 전체 답을 구한다. 그래서 <font color="red">동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능하</font>다.
	- 즉, DP는 부분 문제의 결과를 저장하여 재 계산하지 않을 수 있어야 하는데, 해당 <font color="red">부분 문제가 반복적으로 나타나지 않는다면 재사용이 불가능하니 부분 문제가 중복되지 않는 경우에는 사용할 수 없다.</font>
	- ![[Pasted image 20231020120647.png]]
- Optimal Substructure
	- <font color="red">부분 문제의 최적 결과값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우</font>를 의미한다. 그래서 특정 문제의 정답은 문제의 크기에 상관없이 항상 동일하다.
	- ![[Pasted image 20231020120804.png]]
- DP 파악하기
	- DP로 풀 수 있는 문제인지 확인
		- 현재 문제가 작은 문제들로 이루어진 하나의 함수로 표현될 수 있는지 판단(즉, <font color="red">위의 조건들이 충족되는 문제인지 체그</font>)
	- 문제의 변수 파악
		- DP는 현재 변수에 따라 그 결과값을 찾고 그것을 전달하여 재사용하는 것을 거친다. 즉, 문제 내 변수의 개수를 알아내야 한다.
		- 유명한 <font color="red">Knapsack</font> 문제에서는 index, 무게로 2가지의 변수를 사용한다.
	- 변수 간 관계식 만들기(점화식)
	- 저장
		- 변수간 관계식이 정상 생성됬으면 <font color="red">변수의 값에 따른 결과를 저장</font>해야한다. 이것을 <font color="red">Memoization</font>이라 한다.
		- 변수 값에 따른 결과를 저장할 배열등을 미리 만들고 그 결과를 나올 때마다 배열 내에 저장하고 그 저장된 값을 재사용하는 방식으로 문제를 해결한다.
	- 기저 상태 파악
		- <font color="red">가장 작은 문제의 상태를 알아야</font>한다.
	- 구현
		- 반복문을 사용하여 구현
		- 재귀를 사용하여 구현
- Divide and Conquer(분할 정복)와 차이점
	- 분할 정복과 동적 프로그래밍은 <font color="red">주어진 문제를 작게 쪼개서 하위 문제로 해결하고 연계적으로 큰 문제를 해결한다는 점은 동일하다.</font>
	- 차이점은, 분할정복은 <font color="red">분할된 하위 문제가 동일하게 중복이 일어나지 않은 경우에 사용되며</font>, 동일한 중복 문제가 발생한다면 동적 프로그래밍을 쓴다는 것이다.
