- 전처리 지시자
	- C++ 소스코드를 프로그램으로 만드는 빌드작업은 세 단계를 거침
		- 전처리  : 소스코드에 담긴 메타 정보를 처리
		- 컴파일 : 소스코드를 머신이읽을 수 있는 객체 파일로 변환
		- 링크 : 변환한 여러 객체 파일을 애플리케이션으로 엮음
- 자주 사용하는 전처리 지시자
 
| 전처리 지시자 | 기능 | 사용 예 |
|---|---|---|
| #include [파일] | 지정한 '파일'의 내용을 지시자 위치에 넣음 | 다른 곳에서 정의된 함수를 사용할 목적으로 해당 함수의 선언문이 담긴 헤더 파일을 가져옴 |
| #define [키][값]| 코드에서 '키'에 해당하는 부분을 모두 '값'으로 지정한 내용으로 바꿈 | C에서는 주로 상숫값이나 매크로를 정의하는 데 사용. C++은 상수 및 매크로 정의에 대해 좀 더 개선된 메커니즘을 제공. 매크로는 자칫 위험할 수 있어서 사용시 주의. |
| #ifdef [키], #endif | ifdef(if defined)는 지정한 '키'가 #define 문으로 정의되어 있으면 ifdef로 묶인 코드 블록을 포함시키고, 정의되어 있지 않으면 포함시키지 않는다. | 주로 인클루드 문장이 중복해서 추가되는 것을 막는 용도로 사용. #ifndef로 헤더 파일을 불러오면 먼저 '키'값이 정의되어 있는지 확인한 뒤, 없을시 #define 지시자로 그 '키'를 정의. 그리고 #endif 지시자로 헤더 파일 추가 구문을 닫는다. 이럴시 같은 파일이 여러 번 추가되는 일을 방지할 수 있음 |
| #ifndef [키], #endif | ifndef(if not defined)는 지정한 '키'가 #define 문으로 정의되어 있지 않으면 ifndef로 묶인 코드 블록을 포함시키고, 정의되어 있으면 포함시키지 않는다. | 위와 동일 |
| #pragma [xyz] | xyz에 대한 구체적 동작은 컴파일러마다 다름. 대부분 컴파일러가 #pragma를 지원하며, 주로 전처리 과정에서 이 지시자에 도달할 때 경고나 에러 메시지를 화면에 표시하는 용도로 사용 | |

- 중복 인클루드를 막는 용도로 전처리 지시자를 사용하는 예시. 
```C++
#ifndef MYHEADER_H
#define MYHEADER_H
// 헤더 파일 참조
#endif

// 현재는 #pragma once로 대체
```

- main 함수
	프로그램은 항상 main 함수에서 시작하며, main함수는 int 타입의 값을 리턴. 이 값으로 프로그램의 실행 상태를 표시할 수 있음. main 함수는 매개변수를 받지 않거나 두 개를 받도록 작성할 수 있음
	==int main(int argc, char* argv[])==
	argc는 프로그램에 전달할 인수의 개수를 지정하고, argv는 전달할 인수의 값을 담음. argv[0]에는 프로그램의 이름이 담기는데, 공백 스트링으로 지정될 수도 있어서 프로그램 이름을 참조하려면 이 값보다는 플랫폼에서 제공하는 기능을 사용하는 것이 좋음. 주의할 점은 실제 매개변수는 인덱스 1부터 시작한다는 점.
	
- I/O Stram
	endl은 스트림에 줄바꿈 문자를 추가한 뒤 현재 버퍼에 있는 내용을 출력 장치로 내보낸다. endl은 성능에 영향을 미치기 때문에 특히 루프와 같은 문장에서 남용하면 좋지 않지만, <font color="red">\n은 스트림에 줄바꿈 문자를 추가하지만 버퍼를 자동으로 비우지 않는다.</font>
	C++에서는 format 함수나 스트림 라이브러리를 사용하는 것이 바람직하다. <font color="yellow">C에서 사용하는 printf()나 scanf() 함수는 타입 안정성을 보장하지 않기 때문이다.</font>
	
- 네임스페이스
	코드에서 이름이 서로 충돌하는 문제를 해결하기 위해 나온 개념으로, 네임스페이스 안에 함수 혹은 변수가 정의되면 네임스페이스의 스코프 지정 연산자(::)를 이용하여 구분할 수 있다.
	네임스페이스 블록 안에서 접근할 때는 네임스페이스 접두어를 붙이지 않아도 되며. 이렇게 네임스페이스를 생략하면 코드의 가독성을 좀 더 높일 수 있다. 또한 using 지시자로 네임스페이스 접두어를 생략할 수 있는데, 컴파일러는 using 지시자를 보면 그 뒤에 나오는 문장부터는 using에 지정된 네임스페이스에 속한다고 처리하게 된다.
	하지만 using을 사용하여 네임스페이스를 전부 지우게 되면 사실상 네임스페이스가 없는것과 동일하게 되는서 남용하면 안된다. 다른 해결 방법으로는 해당 네임스페이스 안에 있는 <font color="yellow">함수를 따로 using 지시자를 사용하여 선언하는 것이 가장 효과적이다.</font>
- 중첩 네임스페이스
	다른 네임스페이스 안에 있는 네임스페이스를 의미한다.
	==MyLibraris::Networking::FTP==
- 네임스페이스 앨리어스
	네임스페이스 앨리어스를 사용하면 네임스페이스의 이름을 다르게 만들거나 또는 더 짧게 만들 수 있다.
	==namespace MyFTP = MyLibraris::Networking::FTP;==

- 리터럴
	코드에 표시한 숫자나 스트링과 같은 값을 의미한다. C++은 다양한 표준 리터럴을 제공한다.
	- 십진수 리터럴 : 123
	- 8진수 리터럴 : 0173
	- 16진수 리터럴 : 0x7B
	- 이진수 리터럴 : 0b1111011
	정수형이 아닌 다른 리터럴로는
	- 부동 소수점(float) : 3.14f
	- 배정도 부동 소수점(double) : 3.14
	- 16진수 부동 소수점 : 0x3.ABCp-10, 0Xb.cp121
	- 단일 문자 : 'a'
	- 0으로 끝나는 문자 배열 : "character array"
	숫자 리터럴에서는 자릿수 구분자를 사용할 수 있다. 자릿수 구분자는 작은 따옴표로 표현한다.
	- 23'456'789
	- 0.123'456f

- 변수
	변수를 선언할 때 반드시 값을 대입(초기화)할 필요는 없지만, 초기화하지 않은 변수는 선언할 시점의 메모리가 가지고있는 값을 기반으로 무작위 값이 대입될 수 있으며 해당 현상으로 버그가 발생할 가능성이 있기 때문에 초기화 해주는 것이 좋다. 초기화는 선언시에 대입연산자, 소괄호, 중괄호를 사용하여 처리할 수 있다.
	- 균일 초기화
		- 균일 초기화의 장점중 하나는 <font color="red">좁히기 변환(narrowing conversion)을 방지해준다.</font>
		  ==double x, y, z;==
		  ==int sum{ x + y + z };==
		  위와 같은 코드에서 균일 초기화를 사용하게 되면 축소변환이 불가능하게 되어 컴파일러가 에러를 발생하게 된다.
		- 또 한가지는 구문해석(most vexing parse)에서 자유롭다는 점이다. 생성자를 호출하려 할 때 컴파일러가 함수명인지 변수명인지 구분하기 어려워 발생하는 오류이다.
		  ==Widget w1(); // w1이라는 함수 선언==
		  ==Widget w2{}; // 인수 없는 생성자 호출==
		  균일 초기화를 사용하게 되면 문제없이 생성자를 호출하게 된다.<font color="yellow">사실 내 생각으로는 가독성이 떨어져보이기 때문에 사용하지 2번의 예시처럼 사용하지 않는 편이 더 좋아 보인다.</font>
	